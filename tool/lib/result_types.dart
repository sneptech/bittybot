/// Shared data types for BittyBot inference spike test results and judge outputs.
///
/// LanguageResult and PromptResult are written by on-device integration tests.
/// JudgeScore is written by the judge scripts (judge_quick.dart, judge_full.dart).
/// SpikeReport is the aggregated report produced by generate_report.dart.
library result_types;

// ---------------------------------------------------------------------------
// On-device test output types
// ---------------------------------------------------------------------------

/// Result for a single prompt run during on-device testing.
class PromptResult {
  /// Category of the prompt (e.g., "directions", "food", "emergency").
  final String category;

  /// The source text (English original).
  final String sourceText;

  /// The full prompt sent to the model.
  final String prompt;

  /// The text generated by the on-device model.
  final String generatedOutput;

  /// Approximate token count of the generated output.
  final int tokenCount;

  /// Tokens per second achieved during generation.
  final double tokensPerSecond;

  /// Whether the generated output passes Unicode script validation for this
  /// language (i.e., the correct writing system was used).
  final bool scriptValidationPassed;

  /// Wall-clock duration of the generation in milliseconds.
  final int durationMs;

  const PromptResult({
    required this.category,
    required this.sourceText,
    required this.prompt,
    required this.generatedOutput,
    required this.tokenCount,
    required this.tokensPerSecond,
    required this.scriptValidationPassed,
    required this.durationMs,
  });

  factory PromptResult.fromJson(Map<String, dynamic> json) => PromptResult(
    category: json['category'] as String? ?? '',
    sourceText: json['sourceText'] as String? ?? '',
    prompt: json['prompt'] as String? ?? '',
    generatedOutput: json['generatedOutput'] as String? ?? '',
    tokenCount: (json['tokenCount'] as num?)?.toInt() ?? 0,
    tokensPerSecond: (json['tokensPerSecond'] as num?)?.toDouble() ?? 0.0,
    scriptValidationPassed: json['scriptValidationPassed'] as bool? ?? false,
    durationMs: (json['durationMs'] as num?)?.toInt() ?? 0,
  );

  Map<String, dynamic> toJson() => {
    'category': category,
    'sourceText': sourceText,
    'prompt': prompt,
    'generatedOutput': generatedOutput,
    'tokenCount': tokenCount,
    'tokensPerSecond': tokensPerSecond,
    'scriptValidationPassed': scriptValidationPassed,
    'durationMs': durationMs,
  };

  @override
  String toString() =>
      'PromptResult(category: $category, scriptOk: $scriptValidationPassed, '
      '${tokensPerSecond.toStringAsFixed(1)} tok/s)';
}

/// Aggregated test results for a single language.
class LanguageResult {
  /// Human-readable language name (e.g., "Chinese (Mandarin)").
  final String languageName;

  /// BCP-47 language code (e.g., "zh-cmn", "yue", "es-419").
  final String languageCode;

  /// Script family (e.g., "CJK", "Latin", "Arabic", "Thai", "Cyrillic").
  final String scriptFamily;

  /// Priority tier: "must-have", "high", or "standard".
  final String priority;

  /// Individual prompt results for this language.
  final List<PromptResult> prompts;

  const LanguageResult({
    required this.languageName,
    required this.languageCode,
    required this.scriptFamily,
    required this.priority,
    required this.prompts,
  });

  factory LanguageResult.fromJson(Map<String, dynamic> json) => LanguageResult(
    languageName: json['languageName'] as String? ?? '',
    languageCode: json['languageCode'] as String? ?? '',
    scriptFamily: json['scriptFamily'] as String? ?? '',
    priority: json['priority'] as String? ?? 'standard',
    prompts:
        ((json['prompts'] as List?) ?? [])
            .map((e) => PromptResult.fromJson(e as Map<String, dynamic>))
            .toList(),
  );

  Map<String, dynamic> toJson() => {
    'languageName': languageName,
    'languageCode': languageCode,
    'scriptFamily': scriptFamily,
    'priority': priority,
    'prompts': prompts.map((p) => p.toJson()).toList(),
  };

  /// Fraction of prompts that passed script validation (0.0–1.0).
  double get scriptValidationRate {
    if (prompts.isEmpty) return 0.0;
    final passed = prompts.where((p) => p.scriptValidationPassed).length;
    return passed / prompts.length;
  }

  /// Average tokens per second across all prompts.
  double get averageTokensPerSecond {
    if (prompts.isEmpty) return 0.0;
    final total = prompts.fold(0.0, (sum, p) => sum + p.tokensPerSecond);
    return total / prompts.length;
  }

  @override
  String toString() =>
      'LanguageResult($languageName, ${prompts.length} prompts, '
      'scriptRate: ${(scriptValidationRate * 100).toStringAsFixed(0)}%)';
}

// ---------------------------------------------------------------------------
// Judge output types
// ---------------------------------------------------------------------------

/// LLM judge evaluation scores for a single language.
class JudgeScore {
  /// Human-readable language name (must match LanguageResult.languageName).
  final String languageName;

  /// Script correctness score (1–5).
  /// 1=wrong script entirely, 5=correct script throughout.
  final int scriptScore;

  /// Grammatical plausibility score (1–5).
  /// 1=word salad, 5=fluent natural language.
  final int grammarScore;

  /// Coherence / translation quality score (1–5).
  /// 1=unrelated to prompt, 5=excellent translation.
  final int coherenceScore;

  /// Whether the output is in the correct language (not switched to another).
  final bool isCorrectLanguage;

  /// Free-form notes from the judge (e.g., "Correct Cantonese — uses 㗎").
  final String notes;

  const JudgeScore({
    required this.languageName,
    required this.scriptScore,
    required this.grammarScore,
    required this.coherenceScore,
    required this.isCorrectLanguage,
    required this.notes,
  });

  factory JudgeScore.fromJson(Map<String, dynamic> json) => JudgeScore(
    languageName: json['languageName'] as String? ?? '',
    scriptScore: (json['scriptScore'] as num?)?.toInt() ?? 1,
    grammarScore: (json['grammarScore'] as num?)?.toInt() ?? 1,
    coherenceScore: (json['coherenceScore'] as num?)?.toInt() ?? 1,
    isCorrectLanguage: json['isCorrectLanguage'] as bool? ?? false,
    notes: json['notes'] as String? ?? '',
  );

  Map<String, dynamic> toJson() => {
    'languageName': languageName,
    'scriptScore': scriptScore,
    'grammarScore': grammarScore,
    'coherenceScore': coherenceScore,
    'isCorrectLanguage': isCorrectLanguage,
    'notes': notes,
  };

  /// Whether this language passes the coherence rubric thresholds.
  /// Pass = script >= 3 AND grammar >= 3 AND coherence >= 3 AND correct language.
  bool get passes =>
      scriptScore >= 3 &&
      grammarScore >= 3 &&
      coherenceScore >= 3 &&
      isCorrectLanguage;

  @override
  String toString() =>
      'JudgeScore($languageName: script=$scriptScore, grammar=$grammarScore, '
      'coherence=$coherenceScore, correct=$isCorrectLanguage) -> '
      '${passes ? "PASS" : "FAIL"}';
}

// ---------------------------------------------------------------------------
// Aggregated spike report type
// ---------------------------------------------------------------------------

/// The full structured report produced at the end of the spike.
class SpikeReport {
  /// ISO-8601 timestamp when the report was generated.
  final String timestamp;

  /// Which Flutter binding was used (e.g., "llama_cpp_dart", "fllama").
  final String bindingUsed;

  /// Device information string (e.g., "iPhone 12, iOS 17.3").
  final String deviceInfo;

  /// Total number of languages included in results.
  final int totalLanguages;

  /// Number of languages that passed (script validation >= 80% and judge scores
  /// >= 3 if available).
  final int passedLanguages;

  /// Number of languages that failed.
  final int failedLanguages;

  /// Raw per-language results from on-device tests.
  final List<LanguageResult> languageResults;

  /// Judge scores (may be empty if judge scripts were not run).
  final List<JudgeScore> judgeScores;

  const SpikeReport({
    required this.timestamp,
    required this.bindingUsed,
    required this.deviceInfo,
    required this.totalLanguages,
    required this.passedLanguages,
    required this.failedLanguages,
    required this.languageResults,
    required this.judgeScores,
  });

  factory SpikeReport.fromJson(Map<String, dynamic> json) => SpikeReport(
    timestamp: json['timestamp'] as String? ?? '',
    bindingUsed: json['bindingUsed'] as String? ?? '',
    deviceInfo: json['deviceInfo'] as String? ?? '',
    totalLanguages: (json['totalLanguages'] as num?)?.toInt() ?? 0,
    passedLanguages: (json['passedLanguages'] as num?)?.toInt() ?? 0,
    failedLanguages: (json['failedLanguages'] as num?)?.toInt() ?? 0,
    languageResults:
        ((json['languageResults'] as List?) ?? [])
            .map((e) => LanguageResult.fromJson(e as Map<String, dynamic>))
            .toList(),
    judgeScores:
        ((json['judgeScores'] as List?) ?? [])
            .map((e) => JudgeScore.fromJson(e as Map<String, dynamic>))
            .toList(),
  );

  Map<String, dynamic> toJson() => {
    'timestamp': timestamp,
    'bindingUsed': bindingUsed,
    'deviceInfo': deviceInfo,
    'totalLanguages': totalLanguages,
    'passedLanguages': passedLanguages,
    'failedLanguages': failedLanguages,
    'languageResults': languageResults.map((r) => r.toJson()).toList(),
    'judgeScores': judgeScores.map((s) => s.toJson()).toList(),
  };

  /// Pass rate as a percentage string (e.g., "97.6%").
  String get passRateString {
    if (totalLanguages == 0) return '0%';
    return '${(passedLanguages / totalLanguages * 100).toStringAsFixed(1)}%';
  }

  @override
  String toString() =>
      'SpikeReport($bindingUsed on $deviceInfo: '
      '$passedLanguages/$totalLanguages passed)';
}
