import 'dart:convert';
import 'dart:io';

import 'package:path_provider/path_provider.dart';

/// Serialisable data for a single prompt run captured during on-device testing.
///
/// Field names match the JSON schema that [tool/lib/result_types.dart] expects
/// so that the judge scripts (judge_quick.dart, judge_full.dart) can consume
/// the file directly.
class PromptResultData {
  /// Category of this prompt (e.g., "travel_directions", "travel_food",
  /// "travel_emergency", "travel_greetings", "travel_prices", "travel_basic",
  /// "reference").
  final String category;

  /// English source text.
  final String sourceText;

  /// Full prompt string sent to the model (including Aya chat template tokens).
  final String prompt;

  /// Text generated by the on-device model.
  final String generatedOutput;

  /// Approximate token count of the generated output.
  final int tokenCount;

  /// Tokens per second during generation.
  final double tokensPerSecond;

  /// Whether the output passes Unicode script validation for this language.
  final bool scriptValidationPassed;

  /// Wall-clock generation duration in milliseconds.
  final int durationMs;

  const PromptResultData({
    required this.category,
    required this.sourceText,
    required this.prompt,
    required this.generatedOutput,
    required this.tokenCount,
    required this.tokensPerSecond,
    required this.scriptValidationPassed,
    required this.durationMs,
  });

  /// Serialises to the JSON schema expected by tool/lib/result_types.dart.
  Map<String, dynamic> toJson() => {
        'category': category,
        'sourceText': sourceText,
        'prompt': prompt,
        'generatedOutput': generatedOutput,
        'tokenCount': tokenCount,
        'tokensPerSecond': tokensPerSecond,
        'scriptValidationPassed': scriptValidationPassed,
        'durationMs': durationMs,
      };
}

/// Serialisable data for all prompts run against a single language.
///
/// Field names match the JSON schema that [tool/lib/result_types.dart] expects.
class LanguageResultData {
  /// Human-readable language name (e.g., "Chinese (Mandarin)").
  final String languageName;

  /// BCP-47 or informal language code (e.g., "zh-cmn", "yue", "es-419").
  final String languageCode;

  /// Script family name (e.g., "cjk", "latin", "arabic").
  final String scriptFamily;

  /// Priority tier name (e.g., "mustHave", "standard").
  final String priority;

  /// Individual prompt results for this language.
  final List<PromptResultData> prompts;

  const LanguageResultData({
    required this.languageName,
    required this.languageCode,
    required this.scriptFamily,
    required this.priority,
    required this.prompts,
  });

  /// Serialises to the JSON schema expected by tool/lib/result_types.dart.
  Map<String, dynamic> toJson() => {
        'languageName': languageName,
        'languageCode': languageCode,
        'scriptFamily': scriptFamily,
        'priority': priority,
        'prompts': prompts.map((p) => p.toJson()).toList(),
      };
}

/// Collects per-language test results and writes them as a JSON file.
///
/// The JSON file is written to the app's documents directory so it can be
/// retrieved from the device after test execution:
/// - Android: `adb pull <path> ./spike_results.json`
/// - iOS: Xcode Device Manager → Files tab
///
/// The JSON schema matches [tool/lib/result_types.dart] so that
/// judge_quick.dart and judge_full.dart can consume the file directly.
class ReportWriter {
  /// Accumulated per-language results.
  final List<LanguageResultData> results = [];

  /// Cached documents directory path (resolved once on first use).
  String? _dirPath;

  /// Reads an existing results file, pre-populates [results] with previously
  /// completed entries, and returns the set of already-completed language codes.
  ///
  /// Returns an empty set if the file does not exist or cannot be parsed, so
  /// the caller can treat both cases uniformly (start fresh).
  ///
  /// Pre-populating [results] ensures that [writeResults] / [addLanguageResult]
  /// emit a file that contains *all* results — both the ones loaded here and
  /// any new ones added during this run.
  Future<Set<String>> loadExisting(
      {String filename = 'spike_results.json'}) async {
    _dirPath ??= (await getApplicationDocumentsDirectory()).path;
    final file = File('$_dirPath/$filename');

    if (!file.existsSync()) return {};

    try {
      final raw = await file.readAsString();
      final decoded = jsonDecode(raw);
      if (decoded is! List) return {};

      final completed = <String>{};
      for (final entry in decoded) {
        if (entry is! Map<String, dynamic>) continue;
        final langCode = entry['languageCode'] as String?;
        if (langCode == null) continue;

        // Re-hydrate prompts.
        final rawPrompts = entry['prompts'];
        final prompts = <PromptResultData>[];
        if (rawPrompts is List) {
          for (final p in rawPrompts) {
            if (p is! Map<String, dynamic>) continue;
            prompts.add(PromptResultData(
              category: (p['category'] as String?) ?? '',
              sourceText: (p['sourceText'] as String?) ?? '',
              prompt: (p['prompt'] as String?) ?? '',
              generatedOutput: (p['generatedOutput'] as String?) ?? '',
              tokenCount: (p['tokenCount'] as num?)?.toInt() ?? 0,
              tokensPerSecond:
                  (p['tokensPerSecond'] as num?)?.toDouble() ?? 0.0,
              scriptValidationPassed:
                  (p['scriptValidationPassed'] as bool?) ?? false,
              durationMs: (p['durationMs'] as num?)?.toInt() ?? 0,
            ));
          }
        }

        results.add(LanguageResultData(
          languageName: (entry['languageName'] as String?) ?? langCode,
          languageCode: langCode,
          scriptFamily: (entry['scriptFamily'] as String?) ?? '',
          priority: (entry['priority'] as String?) ?? '',
          prompts: prompts,
        ));
        completed.add(langCode);
      }

      return completed;
    } catch (_) {
      // Corrupt or unreadable file — treat as no prior results.
      results.clear();
      return {};
    }
  }

  /// Appends [result] to the accumulated results list and flushes to disk.
  Future<void> addLanguageResult(LanguageResultData result,
      {String filename = 'spike_results.json'}) async {
    results.add(result);
    await _flush(filename);
  }

  /// Writes current results to disk. Safe to call after every language.
  Future<String> _flush(String filename) async {
    _dirPath ??= (await getApplicationDocumentsDirectory()).path;
    final file = File('$_dirPath/$filename');
    final json = jsonEncode(results.map((r) => r.toJson()).toList());
    await file.writeAsString(json);
    return file.path;
  }

  /// Final write — prints retrieval instructions.
  Future<String> writeResults({String filename = 'spike_results.json'}) async {
    final path = await _flush(filename);
    // ignore: avoid_print
    print('Results written to: $path');
    // ignore: avoid_print
    print('Retrieve with: adb pull $path ./spike_results.json');
    return path;
  }
}
