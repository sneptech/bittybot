import 'dart:convert';
import 'dart:io';

import 'package:path_provider/path_provider.dart';

/// Serialisable data for a single prompt run captured during on-device testing.
///
/// Field names match the JSON schema that [tool/lib/result_types.dart] expects
/// so that the judge scripts (judge_quick.dart, judge_full.dart) can consume
/// the file directly.
class PromptResultData {
  /// Category of this prompt (e.g., "travel_directions", "travel_food",
  /// "travel_emergency", "travel_greetings", "travel_prices", "travel_basic",
  /// "reference").
  final String category;

  /// English source text.
  final String sourceText;

  /// Full prompt string sent to the model (including Aya chat template tokens).
  final String prompt;

  /// Text generated by the on-device model.
  final String generatedOutput;

  /// Approximate token count of the generated output.
  final int tokenCount;

  /// Tokens per second during generation.
  final double tokensPerSecond;

  /// Whether the output passes Unicode script validation for this language.
  final bool scriptValidationPassed;

  /// Wall-clock generation duration in milliseconds.
  final int durationMs;

  const PromptResultData({
    required this.category,
    required this.sourceText,
    required this.prompt,
    required this.generatedOutput,
    required this.tokenCount,
    required this.tokensPerSecond,
    required this.scriptValidationPassed,
    required this.durationMs,
  });

  /// Serialises to the JSON schema expected by tool/lib/result_types.dart.
  Map<String, dynamic> toJson() => {
        'category': category,
        'sourceText': sourceText,
        'prompt': prompt,
        'generatedOutput': generatedOutput,
        'tokenCount': tokenCount,
        'tokensPerSecond': tokensPerSecond,
        'scriptValidationPassed': scriptValidationPassed,
        'durationMs': durationMs,
      };
}

/// Serialisable data for all prompts run against a single language.
///
/// Field names match the JSON schema that [tool/lib/result_types.dart] expects.
class LanguageResultData {
  /// Human-readable language name (e.g., "Chinese (Mandarin)").
  final String languageName;

  /// BCP-47 or informal language code (e.g., "zh-cmn", "yue", "es-419").
  final String languageCode;

  /// Script family name (e.g., "cjk", "latin", "arabic").
  final String scriptFamily;

  /// Priority tier name (e.g., "mustHave", "standard").
  final String priority;

  /// Individual prompt results for this language.
  final List<PromptResultData> prompts;

  const LanguageResultData({
    required this.languageName,
    required this.languageCode,
    required this.scriptFamily,
    required this.priority,
    required this.prompts,
  });

  /// Serialises to the JSON schema expected by tool/lib/result_types.dart.
  Map<String, dynamic> toJson() => {
        'languageName': languageName,
        'languageCode': languageCode,
        'scriptFamily': scriptFamily,
        'priority': priority,
        'prompts': prompts.map((p) => p.toJson()).toList(),
      };
}

/// Collects per-language test results and writes them as a JSON file.
///
/// The JSON file is written to the app's documents directory so it can be
/// retrieved from the device after test execution:
/// - Android: `adb pull <path> ./spike_results.json`
/// - iOS: Xcode Device Manager â†’ Files tab
///
/// The JSON schema matches [tool/lib/result_types.dart] so that
/// judge_quick.dart and judge_full.dart can consume the file directly.
class ReportWriter {
  /// Accumulated per-language results.
  final List<LanguageResultData> results = [];

  /// Appends [result] to the accumulated results list.
  void addLanguageResult(LanguageResultData result) {
    results.add(result);
  }

  /// Serialises all accumulated results to a JSON file on the device filesystem.
  ///
  /// Returns the absolute path of the written file.
  /// Prints the path and an adb pull command for convenience.
  Future<String> writeResults({String filename = 'spike_results.json'}) async {
    final dir = await getApplicationDocumentsDirectory();
    final file = File('${dir.path}/$filename');
    final json = jsonEncode(results.map((r) => r.toJson()).toList());
    await file.writeAsString(json);
    // ignore: avoid_print
    print('Results written to: ${file.path}');
    // ignore: avoid_print
    print('Retrieve with: adb pull ${file.path} ./spike_results.json');
    return file.path;
  }
}
