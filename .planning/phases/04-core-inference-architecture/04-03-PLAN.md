---
phase: 04-core-inference-architecture
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - lib/features/chat/domain/chat_session.dart
  - lib/features/chat/domain/chat_message.dart
  - lib/features/chat/data/chat_repository.dart
  - lib/features/chat/data/chat_repository_impl.dart
  - lib/features/inference/domain/inference_repository.dart
autonomous: true
requirements:
  - CHAT-04

must_haves:
  truths:
    - "Chat sessions and messages can be created, read, and watched reactively from Drift DB"
    - "Domain models provide clean value objects decoupled from Drift-generated data classes"
    - "InferenceRepository interface defines the contract that ChatNotifier and TranslationNotifier consume"
  artifacts:
    - path: "lib/features/chat/domain/chat_session.dart"
      provides: "ChatSession value object with id, title, mode, timestamps"
      contains: "class ChatSession"
    - path: "lib/features/chat/domain/chat_message.dart"
      provides: "ChatMessage value object with id, sessionId, role, content, isTruncated, timestamp"
      contains: "class ChatMessage"
    - path: "lib/features/chat/data/chat_repository.dart"
      provides: "Abstract ChatRepository interface for session/message CRUD and reactive queries"
      contains: "abstract class ChatRepository"
    - path: "lib/features/chat/data/chat_repository_impl.dart"
      provides: "Drift-backed implementation of ChatRepository with reactive watch streams"
      contains: "class DriftChatRepository implements ChatRepository"
    - path: "lib/features/inference/domain/inference_repository.dart"
      provides: "Abstract InferenceRepository interface consumed by notifiers"
      contains: "abstract class InferenceRepository"
  key_links:
    - from: "lib/features/chat/data/chat_repository_impl.dart"
      to: "lib/core/db/app_database.dart"
      via: "DriftChatRepository constructor receives AppDatabase instance"
      pattern: "AppDatabase"
    - from: "lib/features/chat/data/chat_repository_impl.dart"
      to: "lib/features/chat/domain/chat_session.dart"
      via: "Maps Drift ChatSessionData to domain ChatSession"
      pattern: "ChatSession\\("
---

<objective>
Create the chat domain layer (value objects, repository interface, Drift-backed implementation) and the inference repository interface. This is the persistence and data access layer that ChatNotifier and TranslationNotifier will consume.

Purpose: Clean separation between Drift-generated types and domain models. Reactive Drift queries enable real-time UI updates when messages are inserted during streaming.
Output: Five new files establishing the data layer contract.
</objective>

<execution_context>
@~/.claude/mowism/workflows/execute-plan.md
@~/.claude/mowism/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-core-inference-architecture/04-RESEARCH.md
@.planning/phases/04-core-inference-architecture/04-01-SUMMARY.md
@lib/core/db/app_database.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Chat domain models and repository interface</name>
  <files>
    lib/features/chat/domain/chat_session.dart
    lib/features/chat/domain/chat_message.dart
    lib/features/chat/data/chat_repository.dart
    lib/features/inference/domain/inference_repository.dart
  </files>
  <action>
Create the feature directory structures: `lib/features/chat/domain/`, `lib/features/chat/data/`.

**ChatSession value object** (`chat_session.dart`):
```dart
@immutable
class ChatSession {
  final int id;
  final String? title;    // null = auto-derived from first message
  final String mode;      // 'chat' or 'translation'
  final DateTime createdAt;
  final DateTime updatedAt;

  const ChatSession({
    required this.id,
    this.title,
    required this.mode,
    required this.createdAt,
    required this.updatedAt,
  });
}
```

Use `@immutable` from `package:flutter/foundation.dart`.

**ChatMessage value object** (`chat_message.dart`):
```dart
@immutable
class ChatMessage {
  final int id;
  final int sessionId;
  final String role;      // 'user' or 'assistant'
  final String content;
  final bool isTruncated;  // true when user stopped generation
  final DateTime createdAt;

  const ChatMessage({
    required this.id,
    required this.sessionId,
    required this.role,
    required this.content,
    this.isTruncated = false,
    required this.createdAt,
  });

  /// Creates a copy with updated content (used during streaming to append tokens).
  ChatMessage copyWith({String? content, bool? isTruncated}) {
    return ChatMessage(
      id: id,
      sessionId: sessionId,
      role: role,
      content: content ?? this.content,
      isTruncated: isTruncated ?? this.isTruncated,
      createdAt: createdAt,
    );
  }
}
```

**ChatRepository interface** (`chat_repository.dart`):
```dart
abstract class ChatRepository {
  // Session CRUD
  Future<ChatSession> createSession({required String mode, String? title});
  Future<ChatSession?> getSession(int id);
  Future<void> updateSessionTitle(int sessionId, String title);
  Future<void> deleteSession(int sessionId);
  Stream<List<ChatSession>> watchAllSessions();

  // Message CRUD
  Future<ChatMessage> insertMessage({
    required int sessionId,
    required String role,
    required String content,
    bool isTruncated = false,
  });
  Future<void> updateMessageContent(int messageId, String content);
  Future<void> markMessageTruncated(int messageId);
  Future<List<ChatMessage>> getMessagesForSession(int sessionId);
  Stream<List<ChatMessage>> watchMessagesForSession(int sessionId);

  // Bulk operations
  Future<void> deleteAllSessions();
  Future<int> deleteSessionsOlderThan(DateTime cutoff);
}
```

**InferenceRepository interface** (`inference_repository.dart`):
```dart
abstract class InferenceRepository {
  /// Generate a response, streaming tokens.
  /// Returns the requestId for matching with stop().
  int generate({required String prompt, required int nPredict});

  /// Stop the current generation.
  void stop(int requestId);

  /// Clear the model's context (KV cache). Call when starting a new session.
  void clearContext();

  /// Whether a generation is currently in progress.
  bool get isGenerating;

  /// Stream of all inference responses (tokens, done, errors).
  Stream<InferenceResponse> get responseStream;
}
```

Import `InferenceResponse` from `inference_message.dart`.
  </action>
  <verify>
Run `dart analyze lib/features/chat/domain/ lib/features/chat/data/chat_repository.dart lib/features/inference/domain/inference_repository.dart` — zero errors.
  </verify>
  <done>
ChatSession and ChatMessage value objects defined with const constructors and copyWith. ChatRepository interface covers session/message CRUD, reactive watch streams, and bulk operations. InferenceRepository interface defines the contract for generate/stop/clearContext.
  </done>
</task>

<task type="auto">
  <name>Task 2: Drift-backed ChatRepository implementation</name>
  <files>lib/features/chat/data/chat_repository_impl.dart</files>
  <action>
Create `chat_repository_impl.dart` implementing `ChatRepository` using Drift queries against `AppDatabase`.

**Constructor:**
```dart
class DriftChatRepository implements ChatRepository {
  final AppDatabase _db;
  const DriftChatRepository(this._db);
}
```

**Implementation details for each method:**

`createSession`:
- Insert into `chatSessions` using `ChatSessionsCompanion.insert(mode: mode, title: Value.ofNullable(title), createdAt: DateTime.now(), updatedAt: DateTime.now())`
- Return the inserted row mapped to domain `ChatSession`

`getSession`:
- `(select(_db.chatSessions)..where((s) => s.id.equals(id))).getSingleOrNull()`
- Map Drift `ChatSessionData` to domain `ChatSession` (or return null)

`updateSessionTitle`:
- `(update(_db.chatSessions)..where((s) => s.id.equals(sessionId))).write(ChatSessionsCompanion(title: Value(title), updatedAt: Value(DateTime.now())))`

`deleteSession`:
- Delete messages first: `(delete(_db.chatMessages)..where((m) => m.sessionId.equals(sessionId))).go()`
- Then delete session: `(delete(_db.chatSessions)..where((s) => s.id.equals(sessionId))).go()`

`watchAllSessions`:
- `(select(_db.chatSessions)..orderBy([(s) => OrderingTerm.desc(s.updatedAt)])).watch().map((rows) => rows.map(_mapSession).toList())`

`insertMessage`:
- Insert using `ChatMessagesCompanion.insert(sessionId: sessionId, role: role, content: content, isTruncated: Value(isTruncated), createdAt: DateTime.now())`
- Also update the session's `updatedAt` timestamp
- Return mapped domain `ChatMessage`

`updateMessageContent`:
- `(update(_db.chatMessages)..where((m) => m.id.equals(messageId))).write(ChatMessagesCompanion(content: Value(content)))`

`markMessageTruncated`:
- `(update(_db.chatMessages)..where((m) => m.id.equals(messageId))).write(const ChatMessagesCompanion(isTruncated: Value(true)))`

`getMessagesForSession`:
- `(select(_db.chatMessages)..where((m) => m.sessionId.equals(sessionId))..orderBy([(m) => OrderingTerm.asc(m.createdAt)])).get()`
- Map to domain `ChatMessage` list

`watchMessagesForSession`:
- `(select(_db.chatMessages)..where((m) => m.sessionId.equals(sessionId))..orderBy([(m) => OrderingTerm.asc(m.createdAt)])).watch().map((rows) => rows.map(_mapMessage).toList())`

`deleteAllSessions`:
- `delete(_db.chatMessages).go()` then `delete(_db.chatSessions).go()`

`deleteSessionsOlderThan`:
- Get session IDs older than cutoff
- Delete their messages, then delete the sessions
- Return count of deleted sessions

**Private mappers:**
```dart
ChatSession _mapSession(ChatSessionData row) => ChatSession(
  id: row.id,
  title: row.title,
  mode: row.mode,
  createdAt: row.createdAt,
  updatedAt: row.updatedAt,
);

ChatMessage _mapMessage(ChatMessageData row) => ChatMessage(
  id: row.id,
  sessionId: row.sessionId,
  role: row.role,
  content: row.content,
  isTruncated: row.isTruncated,
  createdAt: row.createdAt,
);
```

**Note on Drift generated types:** After Plan 01 regenerates codegen, the generated data classes will be `ChatSessionData` (not `ChatSession` — Drift appends "Data" to avoid collision with the table class). Verify the exact generated class name in `app_database.g.dart` from Plan 01's summary and adjust mapper accordingly. The Drift table class is `ChatSessions` (plural), so the generated row class is `ChatSession` (singular, no Data suffix) in newer Drift versions. Check and adapt.
  </action>
  <verify>
Run `dart analyze lib/features/chat/data/chat_repository_impl.dart` — zero errors. Verify all 12 ChatRepository methods are implemented. Verify mappers convert between Drift types and domain value objects.
  </verify>
  <done>
DriftChatRepository implements all ChatRepository methods with Drift queries. Sessions ordered by updatedAt desc for drawer display. Messages ordered by createdAt asc for chronological chat display. Reactive watch streams auto-update UI when rows are inserted during token streaming.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `dart analyze lib/features/chat/ lib/features/inference/domain/inference_repository.dart` — zero errors
2. ChatSession and ChatMessage are immutable value objects with const constructors
3. ChatRepository interface has 12 methods covering CRUD + reactive + bulk
4. DriftChatRepository correctly maps between Drift-generated and domain types
5. InferenceRepository interface matches LlmService's public API shape
</verification>

<success_criteria>
- Domain models are clean value objects decoupled from Drift internals
- Repository interface enables dependency injection (notifiers depend on interface, not implementation)
- Reactive watch streams use Drift's `.watch()` for auto-updating UI
- All files pass dart analyze with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-inference-architecture/04-03-SUMMARY.md`
</output>
