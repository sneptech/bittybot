---
phase: 03-app-foundation-and-design-system
plan: 05
type: execute
wave: 4
depends_on:
  - "03-02"
  - "03-03"
  - "03-04"
files_modified:
  - lib/main.dart
  - lib/app.dart
  - lib/widgets/app_startup_widget.dart
  - lib/widgets/model_loading_screen.dart
  - lib/widgets/app_startup_error_screen.dart
  - lib/widgets/main_shell.dart
  - test/core/theme/app_theme_test.dart
  - test/core/error/error_messages_test.dart
autonomous: false
requirements:
  - UIUX-01
  - UIUX-02
  - UIUX-03
  - UIUX-04
  - UIUX-05
  - UIUX-06

must_haves:
  truths:
    - "App launches to a dark green themed screen with forest green accents and lime highlights"
    - "When model is not loaded, a dedicated loading screen is shown (not the main UI with disabled inputs)"
    - "When startup fails, an error screen with retry button is shown with tone-appropriate error message"
    - "Locale from settings provider is applied to MaterialApp"
    - "All user-visible text comes from AppLocalizations (no hardcoded English)"
    - "Main shell placeholder is visible when startup succeeds"
  artifacts:
    - path: "lib/main.dart"
      provides: "App entry point with ProviderScope and GoogleFonts offline config"
      contains: "ProviderScope"
    - path: "lib/app.dart"
      provides: "MaterialApp with theme, locale, and localization delegates"
      contains: "MaterialApp"
    - path: "lib/widgets/app_startup_widget.dart"
      provides: "Async gate that shows loading/error/main based on startup state"
      contains: "AppStartupWidget"
    - path: "lib/widgets/model_loading_screen.dart"
      provides: "Dedicated loading screen for model-not-loaded state"
      contains: "ModelLoadingScreen"
    - path: "lib/widgets/app_startup_error_screen.dart"
      provides: "Error screen with retry for startup failures"
      contains: "AppStartupErrorScreen"
    - path: "test/core/theme/app_theme_test.dart"
      provides: "Theme property verification tests"
      contains: "buildDarkTheme"
    - path: "test/core/error/error_messages_test.dart"
      provides: "Error message resolver unit tests"
      contains: "resolveErrorMessage"
  key_links:
    - from: "lib/main.dart"
      to: "lib/app.dart"
      via: "runApp(ProviderScope(child: BittyBotApp()))"
      pattern: "BittyBotApp"
    - from: "lib/app.dart"
      to: "lib/core/theme/app_theme.dart"
      via: "theme: buildDarkTheme()"
      pattern: "buildDarkTheme"
    - from: "lib/app.dart"
      to: "lib/features/settings/application/settings_provider.dart"
      via: "ref.watch(settingsProvider) for locale"
      pattern: "settingsProvider"
    - from: "lib/app.dart"
      to: "lib/core/l10n/app_localizations.dart"
      via: "localizationsDelegates and supportedLocales"
      pattern: "AppLocalizations"
    - from: "lib/app.dart"
      to: "lib/widgets/app_startup_widget.dart"
      via: "home: AppStartupWidget"
      pattern: "AppStartupWidget"
    - from: "lib/widgets/app_startup_widget.dart"
      to: "lib/features/settings/application/settings_provider.dart"
      via: "appStartupProvider watches settingsProvider"
      pattern: "settingsProvider"
---

<objective>
Wire everything together: main.dart entry point, BittyBotApp MaterialApp with theme/locale/localization, AppStartupWidget gate with loading and error screens, placeholder MainShell, and unit tests verifying theme properties and error message resolution.

Purpose: This plan connects all foundation pieces into a running app. After this plan, BittyBot launches, shows the dark green theme, respects locale settings, gates the UI behind startup initialization, and displays tone-appropriate error messages.

Output: A running app with all Phase 3 systems wired together, plus unit tests validating the theme and error message systems.
</objective>

<execution_context>
@/home/max/.claude/mowism/workflows/execute-plan.md
@/home/max/.claude/mowism/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-app-foundation-and-design-system/03-RESEARCH.md
@.planning/phases/03-app-foundation-and-design-system/03-02-SUMMARY.md
@.planning/phases/03-app-foundation-and-design-system/03-03-SUMMARY.md
@.planning/phases/03-app-foundation-and-design-system/03-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create app entry point, MaterialApp shell, and startup widget</name>
  <files>
    lib/main.dart
    lib/app.dart
    lib/widgets/app_startup_widget.dart
    lib/widgets/model_loading_screen.dart
    lib/widgets/app_startup_error_screen.dart
    lib/widgets/main_shell.dart
  </files>
  <action>
    **lib/main.dart:**
    ```dart
    import 'package:flutter/material.dart';
    import 'package:flutter_riverpod/flutter_riverpod.dart';
    import 'package:google_fonts/google_fonts.dart';
    import 'app.dart';

    void main() {
      // CRITICAL: disable runtime font fetching — app is offline-first
      GoogleFonts.config.allowRuntimeFetching = false;
      runApp(const ProviderScope(child: BittyBotApp()));
    }
    ```

    **lib/app.dart:**
    Create `BittyBotApp` as a `ConsumerWidget`:
    - Watch `settingsProvider` for locale override
    - Set `theme: buildDarkTheme()`
    - Set `themeMode: ThemeMode.dark` (force dark — no light theme)
    - Set `localizationsDelegates: AppLocalizations.localizationsDelegates`
    - Set `supportedLocales: AppLocalizations.supportedLocales`
    - Set `locale:` from settingsProvider (null = device default)
    - Implement `localeResolutionCallback` per research pattern (exact match, then language code match, then English fallback)
    - Set `home: AppStartupWidget(onLoaded: (_) => const MainShell())`
    - Handle settingsProvider being in loading/error state gracefully (show MaterialApp even if settings haven't loaded yet — use `valueOrNull`)

    **lib/widgets/app_startup_widget.dart:**
    Create an `appStartupProvider` (Riverpod, keepAlive: true, Future<void>) that eagerly initializes settings:
    ```dart
    @Riverpod(keepAlive: true)
    Future<void> appStartup(Ref ref) async {
      await ref.watch(settingsProvider.future);
      // Phase 4 will add: await ref.watch(modelReadyProvider.future);
    }
    ```

    Create `AppStartupWidget` as a `ConsumerWidget`:
    - Watches `appStartupProvider`
    - `.when(loading: ModelLoadingScreen, error: AppStartupErrorScreen, data: onLoaded)`
    - Takes `WidgetBuilder onLoaded` parameter

    **lib/widgets/model_loading_screen.dart:**
    Create `ModelLoadingScreen` — a full-screen dark-themed loading display:
    - Centered layout on `AppColors.surface` background
    - App name text using `AppLocalizations` (`l10n.appName`) — but NOTE: during startup, AppLocalizations may not be available yet if localization delegates haven't initialized. Use a fallback: show "BittyBot" as a const string on the loading screen since it's a brand name (same in all languages), and use l10n for the loading message if available.
    - Actually, since MaterialApp wraps AppStartupWidget, the localization context IS available inside the startup widget. So `AppLocalizations.of(context)` works here. Use `l10n.modelLoadingTitle` and `l10n.modelLoadingMessage`.
    - A `CircularProgressIndicator` with lime/secondary color
    - Clean, minimal style (UIUX-02) — no heavy decoration

    **lib/widgets/app_startup_error_screen.dart:**
    Create `AppStartupErrorScreen`:
    - Takes `VoidCallback onRetry` and optionally the error object
    - Displays error message using `resolveErrorMessage(l10n, AppError.modelNotLoaded, tone)` where `tone` defaults to `ErrorTone.friendly` (since settings may have failed to load — use a safe default)
    - Shows a retry button (ElevatedButton) with minimum 48x48dp tap target
    - The retry button calls `onRetry` which should `ref.invalidate(appStartupProvider)`

    **lib/widgets/main_shell.dart:**
    Create `MainShell` — a placeholder Scaffold:
    - `AppBar` with title "BittyBot" from `l10n.appName`
    - Body: centered text saying the app is ready (a placeholder for future screens)
    - This will be replaced by the real navigation shell in Phase 5/6
    - Use `EdgeInsetsDirectional` (not `EdgeInsets`) for all padding — RTL-ready from the start

    **RTL considerations across all widgets:**
    - Use `EdgeInsetsDirectional` instead of `EdgeInsets` everywhere
    - Use `AlignmentDirectional` instead of `Alignment` where horizontal alignment matters
    - Use `TextDirection` from the locale context (Flutter handles this automatically via localization delegates)
    - Do NOT use `Row` with hardcoded left/right icons — use `leading`/`trailing` patterns
  </action>
  <verify>
    Run `flutter analyze` — zero errors.
    Run `flutter build apk --debug 2>&1 | tail -5` — build succeeds (or at minimum no Dart compilation errors).
    Confirm `AppStartupWidget` watches `appStartupProvider`.
    Confirm `BittyBotApp` watches `settingsProvider` for locale.
    Confirm no hardcoded English strings in any widget (all text from AppLocalizations or const brand name "BittyBot").
    Confirm `EdgeInsetsDirectional` is used (not `EdgeInsets`) where padding is applied.
  </verify>
  <done>
    App launches, shows dark green loading screen during startup, transitions to main shell after initialization, and displays error screen with retry on failure. Locale from settings is applied. All text is localized. Layout is RTL-ready.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for theme properties and error messages</name>
  <files>
    test/core/theme/app_theme_test.dart
    test/core/error/error_messages_test.dart
  </files>
  <action>
    **test/core/theme/app_theme_test.dart:**

    Write tests verifying the theme contract:

    ```dart
    void main() {
      late ThemeData theme;

      setUp(() {
        theme = buildDarkTheme();
      });

      group('ColorScheme', () {
        test('uses dark brightness', () {
          expect(theme.brightness, Brightness.dark);
          expect(theme.colorScheme.brightness, Brightness.dark);
        });

        test('surface is near-black green', () {
          // Surface should be very dark (luminance < 0.05)
          expect(theme.colorScheme.surface.computeLuminance(), lessThan(0.05));
        });

        test('primary is forest green', () {
          // Primary should be in the green range
          final color = theme.colorScheme.primary;
          expect(color.green, greaterThan(color.red));
          expect(color.green, greaterThan(color.blue));
        });

        test('onSurface is white', () {
          expect(theme.colorScheme.onSurface, equals(const Color(0xFFFFFFFF)));
        });

        test('does not use fromSeed', () {
          // Verify specific colors are set, not tonal palette
          expect(theme.colorScheme.surface, isNot(equals(theme.colorScheme.primary)));
        });
      });

      group('WCAG Contrast', () {
        test('white on primary meets AA (4.5:1)', () {
          final ratio = _contrastRatio(
            theme.colorScheme.onPrimary,
            theme.colorScheme.primary,
          );
          expect(ratio, greaterThanOrEqualTo(4.5));
        });

        test('white on surface meets AA (4.5:1)', () {
          final ratio = _contrastRatio(
            theme.colorScheme.onSurface,
            theme.colorScheme.surface,
          );
          expect(ratio, greaterThanOrEqualTo(4.5));
        });
      });

      group('Typography', () {
        test('bodyMedium is at least 16sp', () {
          expect(theme.textTheme.bodyMedium?.fontSize, greaterThanOrEqualTo(16));
        });

        test('bodyLarge is at least 18sp', () {
          expect(theme.textTheme.bodyLarge?.fontSize, greaterThanOrEqualTo(18));
        });
      });

      group('Accessibility', () {
        test('materialTapTargetSize is padded', () {
          expect(theme.materialTapTargetSize, MaterialTapTargetSize.padded);
        });
      });
    }

    // WCAG contrast ratio helper
    double _contrastRatio(Color foreground, Color background) {
      final fgLuminance = foreground.computeLuminance();
      final bgLuminance = background.computeLuminance();
      final lighter = fgLuminance > bgLuminance ? fgLuminance : bgLuminance;
      final darker = fgLuminance > bgLuminance ? bgLuminance : fgLuminance;
      return (lighter + 0.05) / (darker + 0.05);
    }
    ```

    **test/core/error/error_messages_test.dart:**

    Write tests verifying error message resolution. This requires mocking AppLocalizations or using a test-friendly approach.

    Since AppLocalizations requires a localization context, test the `resolveErrorMessage` function by creating an actual AppLocalizations instance. One approach: use `AppLocalizations.delegate.load(const Locale('en'))` to get an English instance.

    ```dart
    void main() {
      late AppLocalizations l10n;

      setUpAll(() async {
        l10n = await AppLocalizations.delegate.load(const Locale('en'));
      });

      group('resolveErrorMessage', () {
        test('modelNotLoaded friendly returns warm message', () {
          final msg = resolveErrorMessage(l10n, AppError.modelNotLoaded, ErrorTone.friendly);
          expect(msg, contains('warming up'));
        });

        test('modelNotLoaded direct returns clear message', () {
          final msg = resolveErrorMessage(l10n, AppError.modelNotLoaded, ErrorTone.direct);
          expect(msg, contains('not loaded'));
        });

        test('inputTooLong friendly returns gentle message', () {
          final msg = resolveErrorMessage(l10n, AppError.inputTooLong, ErrorTone.friendly);
          expect(msg, isNotEmpty);
        });

        test('inferenceFailed direct returns actionable message', () {
          final msg = resolveErrorMessage(l10n, AppError.inferenceFailed, ErrorTone.direct);
          expect(msg, contains('retry'));
        });

        test('all AppError x ErrorTone combinations return non-empty strings', () {
          for (final error in AppError.values) {
            for (final tone in ErrorTone.values) {
              final msg = resolveErrorMessage(l10n, error, tone);
              expect(msg, isNotEmpty, reason: '$error + $tone should produce a message');
            }
          }
        });
      });
    }
    ```

    Run `flutter test` to execute all tests.
  </action>
  <verify>
    `flutter test` — all tests pass.
    Theme tests verify: dark brightness, near-black surface, forest green primary, white text, 16sp body, padded tap targets, WCAG contrast ratios.
    Error message tests verify: all AppError x ErrorTone combinations produce non-empty strings.
  </verify>
  <done>
    Unit tests confirm: theme contract is met (dark theme, green palette, WCAG contrast, 16sp body, 48dp tap targets), and error message resolver handles all error/tone combinations correctly.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Visual verification of app foundation</name>
  <files>lib/main.dart</files>
  <action>
    Human verification of the complete Phase 3 app foundation. What was built:
    - Dark green theme with Cohere-inspired palette (near-black bg, forest green accents, lime highlights)
    - Localized UI strings across 10 languages including RTL Arabic
    - Accessible tap targets (48x48dp), 16sp body text with Lato font
    - Error message tone system (friendly/direct)
    - App startup gate with loading and error screens
  </action>
  <verify>
    1. Run `flutter run` on a connected device or emulator
    2. Verify the app launches with a dark green background (near-black green, not pure black)
    3. Check that the loading screen shows with lime/green progress indicator
    4. After startup, verify the main shell has:
       - Dark background
       - White text
       - Forest green AppBar or accents
       - Lime/yellow-green highlights visible somewhere (e.g., progress indicator, borders)
    5. Change device locale to Arabic (ar) — verify:
       - UI text switches to Arabic
       - Layout mirrors (RTL) — AppBar title on the right, back button on the right
    6. Change device locale to Japanese (ja) — verify text renders in Japanese
    7. Change device locale to an unsupported language (e.g., Swahili) — verify fallback to English
    8. Inspect body text size — should be visibly larger than typical app text (16sp vs 14sp)
    9. Verify the font is Lato (clean sans-serif, not the default Roboto — check character shapes)
    10. Run `flutter test` — all tests should pass
  </verify>
  <done>
    User approves the visual appearance, localization behavior, and accessibility of the app foundation. Type "approved" to complete Phase 3, or describe any visual/functional issues that need fixing.
  </done>
</task>

</tasks>

<verification>
1. `flutter test` — all tests pass (theme + error messages)
2. `flutter analyze` — zero errors
3. App launches and displays dark green theme
4. Loading screen appears during startup initialization
5. Error screen appears if startup fails (can test by temporarily throwing in appStartupProvider)
6. Locale switching works for all 10 supported languages
7. RTL layout mirrors correctly for Arabic
8. No hardcoded English strings in widget code (grep for string literals in lib/widgets/)
</verification>

<success_criteria>
BittyBot launches as a themed, localized, accessible app shell. The dark green palette is visually correct. Body text is 16sp Lato. Locale switching works across 10 languages including RTL Arabic. Error screens display tone-appropriate messages. The main shell placeholder is ready for Phase 5/6 screens to replace it. All unit tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/03-app-foundation-and-design-system/03-05-SUMMARY.md`
</output>
