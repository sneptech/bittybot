---
phase: 03-app-foundation-and-design-system
plan: 04
type: execute
wave: 3
depends_on:
  - "03-02"
  - "03-03"
files_modified:
  - lib/features/settings/application/settings_provider.dart
  - lib/features/settings/application/settings_provider.g.dart
  - lib/core/error/error_tone.dart
  - lib/core/error/error_messages.dart
autonomous: true
requirements:
  - UIUX-06

must_haves:
  truths:
    - "App settings (locale override and error tone) persist across app restarts via SharedPreferences"
    - "Error messages resolve to the correct tone variant (friendly or direct) based on current settings"
    - "Locale override of null means follow device locale; setting a locale overrides device default"
    - "Error message resolver returns localized strings for all three error scenarios (model not loaded, input too long, inference failed)"
  artifacts:
    - path: "lib/features/settings/application/settings_provider.dart"
      provides: "Riverpod AsyncNotifier for locale and error tone persistence"
      contains: "@Riverpod"
    - path: "lib/core/error/error_tone.dart"
      provides: "ErrorTone enum (friendly, direct)"
      contains: "enum ErrorTone"
    - path: "lib/core/error/error_messages.dart"
      provides: "Tone-aware error message resolver"
      contains: "resolveError"
  key_links:
    - from: "lib/features/settings/application/settings_provider.dart"
      to: "lib/core/error/error_tone.dart"
      via: "imports ErrorTone enum for settings state"
      pattern: "import.*error_tone"
    - from: "lib/core/error/error_messages.dart"
      to: "lib/core/l10n/app_localizations.dart"
      via: "uses AppLocalizations for localized error strings"
      pattern: "AppLocalizations"
    - from: "lib/core/error/error_messages.dart"
      to: "lib/core/error/error_tone.dart"
      via: "switches on ErrorTone to select friendly/direct variant"
      pattern: "ErrorTone"
---

<objective>
Build the settings persistence layer (locale override + error tone toggle) using Riverpod 3.x AsyncNotifier with SharedPreferencesWithCache, and the error message resolution system that returns tone-appropriate localized strings.

Purpose: Settings persistence enables the in-app language override and error tone toggle that the user locked as requirements. The error message resolver is the single entry point for all error strings, ensuring consistent tone across the app.

Output: SettingsProvider that reads/writes to SharedPreferences, ErrorTone enum, and error message resolver function.
</objective>

<execution_context>
@/home/max/.claude/mowism/workflows/execute-plan.md
@/home/max/.claude/mowism/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-app-foundation-and-design-system/03-RESEARCH.md
@.planning/phases/03-app-foundation-and-design-system/03-02-SUMMARY.md
@.planning/phases/03-app-foundation-and-design-system/03-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SettingsProvider with SharedPreferencesWithCache</name>
  <files>
    lib/features/settings/application/settings_provider.dart
    lib/features/settings/application/settings_provider.g.dart
    lib/core/error/error_tone.dart
  </files>
  <action>
    First, create `lib/core/error/error_tone.dart`:

    ```dart
    /// Controls the tone of user-facing error messages.
    /// Friendly: warm, conversational ("Hmm, something went wrong")
    /// Direct: clear, concise ("Translation failed. Please retry.")
    enum ErrorTone { friendly, direct }
    ```

    Then create `lib/features/settings/application/settings_provider.dart`:

    Define an `AppSettings` immutable class (or use a record/class with `copyWith`):
    ```dart
    class AppSettings {
      final Locale? localeOverride;  // null = follow device locale
      final ErrorTone errorTone;
      const AppSettings({this.localeOverride, this.errorTone = ErrorTone.friendly});
      AppSettings copyWith({Locale? Function()? localeOverride, ErrorTone? errorTone}) { ... }
    }
    ```

    Create a `@Riverpod(keepAlive: true)` AsyncNotifier:

    ```dart
    @Riverpod(keepAlive: true)
    class Settings extends _$Settings {
      late SharedPreferencesWithCache _prefs;

      @override
      Future<AppSettings> build() async {
        _prefs = await SharedPreferencesWithCache.create(
          cacheOptions: const SharedPreferencesWithCacheOptions(),
        );
        final localeCode = _prefs.getString('locale');
        final toneStr = _prefs.getString('error_tone');
        return AppSettings(
          localeOverride: localeCode != null ? Locale(localeCode) : null,
          errorTone: toneStr == 'direct' ? ErrorTone.direct : ErrorTone.friendly,
        );
      }

      Future<void> setLocale(Locale? locale) async { ... }
      Future<void> setErrorTone(ErrorTone tone) async { ... }
    }
    ```

    Key implementation details:
    - Use `SharedPreferencesWithCache` (not the deprecated `SharedPreferences.getInstance()`) per research
    - `keepAlive: true` ensures settings are not disposed when no widgets are listening
    - `setLocale(null)` removes the locale key and reverts to device default
    - `setLocale(Locale('ar'))` sets the override to Arabic
    - `setErrorTone(ErrorTone.direct)` persists `'direct'` string
    - State updates use `state = AsyncValue.data(...)` to trigger rebuilds

    Run `dart run build_runner build --delete-conflicting-outputs` to generate the `.g.dart` file.

    **Important:** The Riverpod 3.x code-gen generates providers with specific naming. The provider will be accessible as `settingsProvider` (from `Settings` class name, lowercased first letter).
  </action>
  <verify>
    `dart run build_runner build --delete-conflicting-outputs` succeeds.
    `flutter analyze` passes with no errors in settings files.
    Generated `.g.dart` file exists at `lib/features/settings/application/settings_provider.g.dart`.
    `settingsProvider` is a valid Riverpod provider (check generated code).
  </verify>
  <done>
    SettingsProvider reads locale and error tone from SharedPreferences on init, provides `setLocale` and `setErrorTone` mutations that persist changes, and triggers widget rebuilds via Riverpod state updates.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create error message resolver with tone switching</name>
  <files>
    lib/core/error/error_messages.dart
  </files>
  <action>
    Create `lib/core/error/error_messages.dart` with a function that resolves error strings based on the active tone.

    Define an enum for error types (not to be confused with ErrorTone):

    ```dart
    enum AppError {
      modelNotLoaded,
      inputTooLong,
      inferenceFailed,
      generic,
    }
    ```

    Create the resolver function:

    ```dart
    /// Resolves the localized error message for the given [error] and [tone].
    ///
    /// Uses [AppLocalizations] to fetch the correct string. Each error has
    /// both a friendly and direct variant in the ARB files.
    String resolveErrorMessage(
      AppLocalizations l10n,
      AppError error,
      ErrorTone tone,
    ) {
      return switch ((error, tone)) {
        (AppError.modelNotLoaded, ErrorTone.friendly) => l10n.modelNotLoadedFriendly,
        (AppError.modelNotLoaded, ErrorTone.direct) => l10n.modelNotLoadedDirect,
        (AppError.inputTooLong, ErrorTone.friendly) => l10n.inputTooLongFriendly,
        (AppError.inputTooLong, ErrorTone.direct) => l10n.inputTooLongDirect,
        (AppError.inferenceFailed, ErrorTone.friendly) => l10n.inferenceFailedFriendly,
        (AppError.inferenceFailed, ErrorTone.direct) => l10n.inferenceFailedDirect,
        (AppError.generic, ErrorTone.friendly) => l10n.genericErrorFriendly,
        (AppError.generic, ErrorTone.direct) => l10n.genericErrorDirect,
      };
    }
    ```

    This uses Dart 3 pattern matching on a record `(AppError, ErrorTone)` for exhaustive switching. If any combination is missing, the compiler will flag it — no runtime surprises.

    Import `AppLocalizations` from the generated localization file. Import `ErrorTone` from `error_tone.dart`.

    **Error presentation style (Claude's discretion):**
    Document in a comment at the top of the file the recommended presentation per error type:
    - `modelNotLoaded`: Full-screen gate (AppStartupWidget handles this)
    - `inputTooLong`: Inline validation text below input field
    - `inferenceFailed`: SnackBar with retry action
    - `generic`: SnackBar
    These are recommendations for consuming code in later phases; this file only resolves the message string.
  </action>
  <verify>
    `flutter analyze` passes with no errors.
    The switch expression covers all `(AppError, ErrorTone)` combinations (Dart analyzer will flag missing cases).
    `resolveErrorMessage` accepts `AppLocalizations`, `AppError`, and `ErrorTone` parameters.
  </verify>
  <done>
    Error message resolver provides tone-aware localized error strings for all three error scenarios plus a generic fallback. The function is exhaustive — adding a new AppError variant requires adding both tone variants (compiler-enforced).
  </done>
</task>

</tasks>

<verification>
1. `dart run build_runner build` succeeds (generates settings provider and drift code)
2. `flutter analyze` passes with zero errors
3. `settingsProvider` is generated and accessible
4. `resolveErrorMessage` handles all `AppError` x `ErrorTone` combinations
5. `ErrorTone` enum has exactly two values: `friendly`, `direct`
6. Settings read from SharedPreferences on init (check for `SharedPreferencesWithCache.create`)
</verification>

<success_criteria>
Settings persistence works: locale override and error tone are read from SharedPreferences on app startup and written on every change. Error message resolver returns the correct localized, tone-appropriate string for every error scenario. Both systems are ready for wiring into the app shell.
</success_criteria>

<output>
After completion, create `.planning/phases/03-app-foundation-and-design-system/03-04-SUMMARY.md`
</output>
