---
phase: 02-model-distribution
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - lib/features/model_distribution/model_distribution_notifier.dart
  - lib/features/model_distribution/providers.dart
  - lib/features/model_distribution/widgets/download_screen.dart
  - lib/features/model_distribution/widgets/cellular_warning_dialog.dart
  - lib/features/model_distribution/widgets/resume_prompt_dialog.dart
autonomous: true
requirements:
  - MODL-01
  - MODL-02
  - MODL-03

must_haves:
  truths:
    - "Notifier orchestrates full lifecycle: check model -> preflight -> connectivity gate -> download -> verify -> load"
    - "On Wi-Fi the download starts automatically after preflight checks pass"
    - "On cellular a warning dialog shows the file size (~2.14 GB) and offers proceed/wait options"
    - "On reopen after interrupted download a resume prompt appears (not auto-resume) showing saved progress percentage"
    - "Progress bar displays downloaded/total bytes, transfer speed, and ETA during active download"
    - "Download progress is persisted to shared_preferences so resume prompt shows correct starting percentage"
    - "After download completes a Verifying state is shown before transitioning"
    - "Repeated failures (3+) show troubleshooting hints below the retry button"
  artifacts:
    - path: "lib/features/model_distribution/model_distribution_notifier.dart"
      provides: "Riverpod Notifier orchestrating entire download-verify-load lifecycle"
      contains: "class ModelDistributionNotifier"
      min_lines: 100
    - path: "lib/features/model_distribution/providers.dart"
      provides: "Riverpod provider declarations for model distribution feature"
      contains: "modelDistributionProvider"
    - path: "lib/features/model_distribution/widgets/download_screen.dart"
      provides: "Full download screen UI consuming all notifier states"
      contains: "DownloadScreen"
      min_lines: 80
    - path: "lib/features/model_distribution/widgets/cellular_warning_dialog.dart"
      provides: "Cellular data warning dialog with file size and proceed/wait buttons"
      contains: "CellularWarningDialog"
    - path: "lib/features/model_distribution/widgets/resume_prompt_dialog.dart"
      provides: "Resume confirmation dialog with explanation text and progress"
      contains: "ResumePromptDialog"
  key_links:
    - from: "lib/features/model_distribution/model_distribution_notifier.dart"
      to: "lib/features/model_distribution/sha256_verifier.dart"
      via: "calls verifyModelFile after download completes and on subsequent launches"
      pattern: "verifyModelFile"
    - from: "lib/features/model_distribution/model_distribution_notifier.dart"
      to: "lib/features/model_distribution/storage_preflight.dart"
      via: "calls checkStorageSpace and checkConnectionType during preflight"
      pattern: "checkStorageSpace|checkConnectionType"
    - from: "lib/features/model_distribution/widgets/download_screen.dart"
      to: "lib/features/model_distribution/providers.dart"
      via: "watches modelDistributionProvider to render current state"
      pattern: "ref\\.watch.*modelDistribution"
    - from: "lib/features/model_distribution/model_distribution_notifier.dart"
      to: "background_downloader"
      via: "FileDownloader().download() with DownloadTask configuration"
      pattern: "FileDownloader|DownloadTask"
---

<objective>
Build the Riverpod notifier that orchestrates the entire model download lifecycle (check -> preflight -> download -> verify -> load) and the download screen UI that renders every state with the user-specified design: BittyBot logo, forest green progress bar, speed/ETA display, cellular warning dialog, resume prompt, and error escalation.

Purpose: This is the core of Phase 2 -- the download orchestration logic and the first-launch screen the user sees. Every locked decision about the download experience is implemented here.
Output: A working download service and UI that handles the complete first-launch flow from preflight checks through download completion and verification.
</objective>

<execution_context>
@/home/max/.claude/get-shit-done/workflows/execute-plan.md
@/home/max/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-model-distribution/02-RESEARCH.md
@.planning/phases/02-model-distribution/02-CONTEXT.md
@.planning/phases/02-model-distribution/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ModelDistributionNotifier with full download lifecycle orchestration</name>
  <files>
    lib/features/model_distribution/model_distribution_notifier.dart
    lib/features/model_distribution/providers.dart
  </files>
  <action>
    1. Create `lib/features/model_distribution/model_distribution_notifier.dart` — a Riverpod 3.x `Notifier` class managing the full download-verify-load state machine:

       **Class: `ModelDistributionNotifier extends Notifier<ModelDistributionState>`**

       **`build()` method:** Return `const CheckingModelState()` as initial state.

       **`initialize()` method (called once on app start):**
       a. Set state to `CheckingModelState`
       b. Resolve model file path: `getApplicationSupportDirectory()` + `/models/tiny-aya-global-q4_k_m.gguf`
       c. Ensure the models directory exists (`Directory.create(recursive: true)`)
       d. If model file exists:
          - Set state to `VerifyingState`
          - Call `verifyModelFile(filePath)` from sha256_verifier.dart
          - If valid: proceed to `_proceedToLoad()`
          - If invalid: delete the corrupt file, fall through to download path
       e. If model file doesn't exist:
          - Check shared_preferences for saved download progress (key: `'model_download_progress'`)
          - If saved progress > 0.0: set state to `ResumePromptState(progressFraction: savedProgress)` and return (wait for user)
          - If no saved progress: call `_runPreflight()`

       **`_runPreflight()` method (the "Preparing download..." state):**
       a. Set state to `PreflightState`
       b. Check storage via `checkStorageSpace(modelDirPath)` from storage_preflight.dart
       c. If insufficient: set state to `InsufficientStorageState(neededBytes, availableBytes)` and return
       d. Check connectivity via `checkConnectionType()` from storage_preflight.dart
       e. If `ConnectionType.none`: set state to `ErrorState(message: 'No internet connection. Connect to Wi-Fi or cellular data to download the language model.', failureCount: 0)` and return
       f. If `ConnectionType.cellular`: set state to `CellularWarningState` and return (wait for user)
       g. If `ConnectionType.wifi`: call `_startDownload()`

       **`confirmCellularDownload()` method:** Called when user accepts cellular warning. Call `_startDownload()`.

       **`confirmResume()` method:** Called when user confirms resume. Call `_startDownload()`.

       **`retryDownload()` method:** Called from error state retry button. Increment an internal `_failureCount` tracker, then call `_runPreflight()` again.

       **`_startDownload()` method:**
       a. Configure `FileDownloader()` globally (call once):
          ```dart
          await FileDownloader().configure(globalConfig: [
            (Config.runInForegroundIfFileLargerThan, 500),
          ]);
          ```
       b. Configure notifications:
          ```dart
          FileDownloader().configureNotification(
            running: const TaskNotification('Downloading language model', '{progress}% complete'),
            paused: const TaskNotification('Download paused', 'Tap to resume'),
            complete: const TaskNotification('Download complete', 'Open BittyBot to continue'),
            error: const TaskNotification('Download failed', 'Tap to retry'),
            progressBar: true,
          );
          ```
       c. Create `DownloadTask` with:
          - `url: ModelConstants.downloadUrl`
          - `filename: ModelConstants.filename`
          - `directory: ModelConstants.modelSubdirectory`
          - `baseDirectory: BaseDirectory.applicationSupport`
          - `updates: Updates.statusAndProgress`
          - `allowPause: true`
          - `priority: 0` (UIDT on Android 14+)
          - `retries: 3`
          - `displayName: 'Tiny Aya language model'`
       d. Set state to `DownloadingState(progressFraction: 0.0, downloadedBytes: 0, totalBytes: ModelConstants.fileSizeBytes, networkSpeedMBps: 0.0, timeRemaining: null)`
       e. Call `FileDownloader().download(task, onProgress: _onProgress, onStatus: _onStatus)`
       f. Handle the result: if `TaskStatus.complete`, call `_onDownloadComplete()`. If `TaskStatus.failed` or `TaskStatus.notFound`, call `_onDownloadFailed(statusMessage)`.

       **`_onProgress(TaskProgressUpdate update)` callback:**
       a. Update state to `DownloadingState` with:
          - `progressFraction: update.progress` (0.0-1.0, but -1.0 means unknown)
          - `downloadedBytes: (update.progress * ModelConstants.fileSizeBytes).round()` (approximate; use expectedFileSize if available)
          - `totalBytes: ModelConstants.fileSizeBytes`
          - `networkSpeedMBps: update.hasNetworkSpeed ? update.networkSpeed : 0.0`
          - `timeRemaining: update.hasTimeRemaining ? update.timeRemaining : null`
       b. Persist progress to shared_preferences — but throttle writes: only persist when progress changes by >= 5% (0.05) compared to last persisted value. Store a `_lastPersistedProgress` double field to track this.
          ```dart
          final prefs = await SharedPreferences.getInstance();
          await prefs.setDouble('model_download_progress', update.progress);
          ```

       **`_onStatus(TaskStatusUpdate update)` callback:**
       Handle `TaskStatus.paused` — the download was paused by the OS or user backgrounding. The notifier doesn't need to change state here because `background_downloader` handles resume internally. Just log it.

       **`_onDownloadComplete()` method:**
       a. Set state to `VerifyingState`
       b. Resolve full file path
       c. Call `verifyModelFile(filePath)` from sha256_verifier.dart
       d. If valid: clear saved progress from shared_preferences, call `_proceedToLoad()`
       e. If invalid: delete the file, clear saved progress, set state to `ErrorState(message: 'Download verification failed. The file may be corrupted. Please try again.', failureCount: _failureCount + 1)`

       **`_onDownloadFailed(String message)` method:**
       a. Increment `_failureCount`
       b. Set state to `ErrorState(message: message, failureCount: _failureCount)`
       c. Error escalation per Claude's discretion:
          - failureCount 1-2: message is just the error string
          - failureCount 3+: append troubleshooting hints to message:
            "Troubleshooting:\n- Make sure you have at least 2.5 GB of free storage\n- Try switching from cellular to Wi-Fi\n- Force-close the app and reopen\n- If the problem persists, the server may be temporarily busy"

       **`_proceedToLoad()` method:**
       a. Check RAM via `isLowMemoryDevice()` from storage_preflight.dart
       b. If low memory: set state to `LowMemoryWarningState(availableMB: deviceRamMB)` and return
       c. Otherwise: set state to `LoadingModelState`
       d. NOTE: Phase 4 wires the actual model load here. For now, after a brief delay (or immediately), transition to `ModelReadyState`. Expose `modelFilePath` as a getter on the notifier so Phase 4 can access it. Add a TODO comment: `// TODO(phase-4): Wire actual llama_cpp inference load here`
       e. For now: `state = const ModelReadyState()` — Phase 4 will replace the LoadingModel -> ModelReady transition with actual inference initialization.

       **`acknowledgeMemoryWarning()` method:** Called when user dismisses low memory warning. Set state to `LoadingModelState`, then same as _proceedToLoad() step c-e but skip the RAM check.

       **Store `_modelFilePath` as a late String field** set during `initialize()`. Expose a getter `String get modelFilePath => _modelFilePath`.

    2. Create `lib/features/model_distribution/providers.dart`:
       ```dart
       import 'package:flutter_riverpod/flutter_riverpod.dart';
       import 'model_distribution_notifier.dart';
       import 'model_distribution_state.dart';

       final modelDistributionProvider =
           NotifierProvider<ModelDistributionNotifier, ModelDistributionState>(
         ModelDistributionNotifier.new,
       );
       ```
       Note: If using Riverpod 3.x code generation (@riverpod annotation), use that instead. But since Phase 1 may not have set up riverpod_generator/build_runner, use the manual provider declaration approach above. Add a comment noting that migration to codegen is possible later.

    AVOID:
    - Do NOT use `StateNotifier` (Riverpod 2.x legacy) — use `Notifier` (Riverpod 3.x)
    - Do NOT use `requiresWiFi: true` on the DownloadTask — the cellular gate is handled in app logic via the CellularWarningState, not at the OS level
    - Do NOT auto-resume on reopen — per user decision, show a resume confirmation prompt first
    - Do NOT call `File.readAsBytes()` anywhere — always delegate to sha256_verifier.dart's chunked approach
    - Do NOT keep the screen awake during download — per user decision, normal sleep behavior
  </action>
  <verify>
    - `dart analyze lib/features/model_distribution/model_distribution_notifier.dart` reports no errors
    - `dart analyze lib/features/model_distribution/providers.dart` reports no errors
    - `grep "class ModelDistributionNotifier" lib/features/model_distribution/model_distribution_notifier.dart` matches
    - `grep "FileDownloader" lib/features/model_distribution/model_distribution_notifier.dart` matches — confirms background_downloader integration
    - `grep "verifyModelFile" lib/features/model_distribution/model_distribution_notifier.dart` matches — confirms SHA-256 verification is called
    - `grep "shared_preferences\|SharedPreferences" lib/features/model_distribution/model_distribution_notifier.dart` matches — confirms progress persistence
    - `grep "modelDistributionProvider" lib/features/model_distribution/providers.dart` matches
  </verify>
  <done>
    ModelDistributionNotifier exists with complete lifecycle: initialize() checks for existing model and verifies SHA-256, handles resume prompt from saved progress, runs preflight (storage + connectivity), shows cellular warning, starts background_downloader with correct DownloadTask config (allowPause, priority 0, UIDT), persists progress throttled at 5% increments, verifies SHA-256 after download, checks RAM before load, and transitions through all 11 states. Provider declaration exposes the notifier for UI consumption.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create download screen UI with all state renderings, cellular warning dialog, and resume prompt</name>
  <files>
    lib/features/model_distribution/widgets/download_screen.dart
    lib/features/model_distribution/widgets/cellular_warning_dialog.dart
    lib/features/model_distribution/widgets/resume_prompt_dialog.dart
  </files>
  <action>
    1. Create `lib/features/model_distribution/widgets/download_screen.dart` — a `ConsumerWidget` that watches `modelDistributionProvider` and renders the appropriate UI for each state:

       **Overall layout (per user decision):**
       - Minimal, clean screen — dark background (use `Colors.black` or `Color(0xFF121212)` as placeholder; Phase 3 defines exact theme)
       - BittyBot logo centered above download area — use `Image.asset('assets/logo_greyscale.png', width: 120)`. If asset doesn't exist yet (user supplies it), use a placeholder `Icon(Icons.smart_toy, size: 80, color: Colors.grey)` wrapped in a comment noting the asset TODO.
       - Below logo: small explanatory text "Downloading language model for offline use" in light grey

       **State-specific rendering (exhaustive switch on ModelDistributionState):**

       **CheckingModelState:** Center spinner with text "Checking for language model..."

       **PreflightState:** Center spinner with text "Preparing download..." (per user decision — this is the connectivity + storage check phase)

       **ResumePromptState:** Show the resume prompt dialog automatically (via a `WidgetsBinding.instance.addPostFrameCallback` or by rendering it inline). The dialog content is in resume_prompt_dialog.dart. Show the progress bar at the saved percentage behind/below the dialog.

       **CellularWarningState:** Show the cellular warning dialog automatically. Dialog content in cellular_warning_dialog.dart.

       **InsufficientStorageState:** Show error card with:
         - Warning icon
         - "Not enough storage"
         - "BittyBot needs {neededGB} GB free. You have {availableGB} GB available."
         - "Free up space and try again" button that calls `ref.read(modelDistributionProvider.notifier).retryDownload()`

       **DownloadingState:** The main download view:
         - Progress bar: `LinearProgressIndicator` with value = `progressFraction` (0.0-1.0). If -1.0 (unknown), use `null` for indeterminate mode.
         - Forest green color: use `Color(0xFF2D6A4F)` as placeholder (easy to swap when Phase 3 defines palette). Apply via `LinearProgressIndicator(valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF2D6A4F)))`.
         - Below progress bar, centered, small font (`fontSize: 12`, light grey):
           - Line 1: "{downloadedMB} MB / {totalMB} MB" (convert bytes to MB with 1 decimal)
           - Line 2: "{speedMBps} MB/s - {timeRemainingFormatted} remaining" (format Duration as "Xh Ym" or "Ym Zs"; show "Calculating..." if timeRemaining is null)
         - No cancel button (per user decision)

       **VerifyingState:** Center spinner with text "Verifying download..."

       **LowMemoryWarningState:** Show warning card:
         - Warning icon (amber)
         - "Low memory warning"
         - "Your device has {availableMB} MB of RAM. Performance may be poor or the app may not function at all on this device." (per user decision — warn honestly)
         - "Continue anyway" button that calls `ref.read(modelDistributionProvider.notifier).acknowledgeMemoryWarning()`

       **LoadingModelState:** This state should NOT appear on the download screen — it means download is done and the app should transition to the main screen. But render a fallback: spinner + "Loading language model..."

       **ModelReadyState:** Same as LoadingModel — should not appear here. Render nothing or a brief "Ready!" that immediately navigates away. (Plan 03 handles the routing logic.)

       **ErrorState:** Show error card with:
         - Error icon (red)
         - Error message text
         - "Try again" button that calls `ref.read(modelDistributionProvider.notifier).retryDownload()`
         - If `failureCount >= 3`: show troubleshooting hints below the button in a subtle text block (the hints are generated by the notifier in the error message, so just render `state.message` which includes them)

       **Helper methods:**
       - `_formatBytes(int bytes)` -> "X.X MB" or "X.XX GB"
       - `_formatDuration(Duration? d)` -> "Xh Ym", "Ym Zs", or "Calculating..."
       - `_formatSpeed(double mbps)` -> "X.X MB/s"

    2. Create `lib/features/model_distribution/widgets/cellular_warning_dialog.dart`:
       - A widget (or a static method that shows a dialog) with:
         - Title: "Download on cellular data?"
         - Body: "This download is ~2.14 GB. Continue on cellular?" (per user decision, exact wording)
         - Two buttons:
           - "Wait for Wi-Fi" — dismisses dialog (notifier stays in CellularWarningState; user can reopen app on Wi-Fi later which re-runs preflight)
           - "Download now" — calls `ref.read(modelDistributionProvider.notifier).confirmCellularDownload()`
       - Style: Use AlertDialog or a custom modal bottom sheet. Keep it simple and clean.

    3. Create `lib/features/model_distribution/widgets/resume_prompt_dialog.dart`:
       - A widget (or static method) with:
         - Title: "Resume download?"
         - Body: "BittyBot needs this language model to translate and chat offline." (per user decision — explain why)
         - Show current progress: "Download is {progressPercent}% complete"
         - Two buttons:
           - "Start over" — clears saved progress from shared_preferences, calls `ref.read(modelDistributionProvider.notifier).retryDownload()` (which will run preflight from scratch)
           - "Resume" — calls `ref.read(modelDistributionProvider.notifier).confirmResume()`
       - The progress bar behind/below should show the saved fraction (passed via `ResumePromptState.progressFraction`)

    **Design notes:**
    - All text colors: use `Colors.white70` or `Colors.grey[300]` on dark background — these are placeholders that Phase 3 will refine
    - All placeholder colors are defined as local constants at the top of each file with comments like `// TODO(phase-3): Replace with design system color`
    - Font sizes: explanatory text 14sp, progress details 12sp, error messages 14sp, dialog titles 18sp
    - The download screen is a full `Scaffold` — it replaces the entire screen on first launch

    AVOID:
    - Do NOT add a cancel button (per user decision)
    - Do NOT keep the screen awake (per user decision — normal sleep behavior)
    - Do NOT auto-resume — always show resume prompt first (per user decision)
    - Do NOT implement the greyscale-to-color logo transition here — that belongs on the main app screen (Plan 03)
    - Do NOT add navigation logic — Plan 03 handles routing between download screen and main app
  </action>
  <verify>
    - `dart analyze lib/features/model_distribution/widgets/` reports no errors
    - `grep "class DownloadScreen" lib/features/model_distribution/widgets/download_screen.dart` matches
    - `grep "CellularWarningDialog\|cellularWarning" lib/features/model_distribution/widgets/cellular_warning_dialog.dart` matches
    - `grep "ResumePromptDialog\|resumePrompt" lib/features/model_distribution/widgets/resume_prompt_dialog.dart` matches
    - `grep "ref.watch\|ref.read" lib/features/model_distribution/widgets/download_screen.dart` matches — confirms Riverpod integration
    - Verify exhaustive switch: the download_screen.dart should handle all 11 state variants (CheckingModel, Preflight, ResumePrompt, CellularWarning, InsufficientStorage, Downloading, Verifying, LowMemoryWarning, LoadingModel, ModelReady, Error)
  </verify>
  <done>
    Download screen renders all 11 state variants: checking spinner, preflight spinner, resume prompt dialog with saved progress, cellular warning dialog with proceed/wait options, insufficient storage error with space details, downloading view with forest green progress bar showing bytes/speed/ETA, verifying spinner, low memory warning with honest message and continue button, loading fallback, ready fallback, and error with retry + troubleshooting hints after 3 failures. Cellular warning dialog shows exact "~2.14 GB" file size. Resume prompt explains why the download is needed. No cancel button. No screen wake lock.
  </done>
</task>

</tasks>

<verification>
1. `flutter analyze` reports no errors across all modified files
2. Notifier handles complete lifecycle: check -> preflight -> [cellular gate | resume prompt] -> download -> verify -> [RAM check] -> load -> ready
3. Download progress persisted to shared_preferences at 5% throttle intervals
4. Cellular warning shows exact file size per user decision
5. Resume prompt shows saved percentage, not 0%
6. Error state escalates after 3+ failures with troubleshooting hints
7. Download screen exhaustively switches on all 11 state variants
8. No cancel button, no screen wake lock, no auto-resume
</verification>

<success_criteria>
- ModelDistributionNotifier orchestrates full download lifecycle with all state transitions
- background_downloader configured with allowPause, priority 0, foreground service, and notifications
- Download screen renders every state with the user-specified minimal design
- Cellular warning dialog shows "~2.14 GB" and offers proceed/wait
- Resume prompt shows saved progress and explains why download is needed
- Error escalation shows troubleshooting hints after 3+ failures
- All files compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-model-distribution/02-02-SUMMARY.md`
</output>
