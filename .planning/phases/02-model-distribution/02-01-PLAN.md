---
phase: 02-model-distribution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pubspec.yaml
  - android/app/src/main/AndroidManifest.xml
  - ios/Runner/AppDelegate.swift
  - ios/Runner.xcodeproj/project.pbxproj
  - ios/Runner/Info.plist
  - lib/features/model_distribution/model_constants.dart
  - lib/features/model_distribution/model_distribution_state.dart
  - lib/features/model_distribution/sha256_verifier.dart
  - lib/features/model_distribution/storage_preflight.dart
autonomous: true
requirements:
  - MODL-01
  - MODL-02
  - MODL-04

must_haves:
  truths:
    - "All required dependencies (background_downloader, connectivity_plus, crypto, path_provider, flutter_riverpod, shared_preferences, disk_space_plus, system_info_plus) resolve successfully"
    - "Android manifest declares all permissions and services needed for background download with UIDT and notifications"
    - "iOS AppDelegate has notification delegate and Background Fetch capability is enabled"
    - "SHA-256 chunked verifier computes correct hash for large files without loading entire file into memory"
    - "Model constants contain correct download URL, SHA-256 hash, filename, and file size"
    - "State machine sealed class covers all download lifecycle states exhaustively"
  artifacts:
    - path: "pubspec.yaml"
      provides: "All Phase 2 dependencies"
      contains: "background_downloader"
    - path: "android/app/src/main/AndroidManifest.xml"
      provides: "Android permissions and service declarations for background download"
      contains: "FOREGROUND_SERVICE_DATA_SYNC"
    - path: "ios/Runner/AppDelegate.swift"
      provides: "iOS notification delegate for background_downloader"
      contains: "UNUserNotificationCenter"
    - path: "lib/features/model_distribution/model_constants.dart"
      provides: "Hard-coded model URL, SHA-256, filename, size"
      contains: "d01d995272af305b2b843efcff8a10cf9869cf53e764cb72b0e91b777484570a"
    - path: "lib/features/model_distribution/model_distribution_state.dart"
      provides: "Sealed class with all state variants for download lifecycle"
      contains: "sealed class ModelDistributionState"
    - path: "lib/features/model_distribution/sha256_verifier.dart"
      provides: "Chunked SHA-256 verification using compute() isolate"
      contains: "startChunkedConversion"
    - path: "lib/features/model_distribution/storage_preflight.dart"
      provides: "Disk space check and RAM check helpers"
      contains: "getFreeDiskSpaceForPath"
  key_links:
    - from: "lib/features/model_distribution/sha256_verifier.dart"
      to: "lib/features/model_distribution/model_constants.dart"
      via: "imports sha256Hash constant for comparison"
      pattern: "ModelConstants\\.sha256Hash"
    - from: "lib/features/model_distribution/model_distribution_state.dart"
      to: "lib/features/model_distribution/model_constants.dart"
      via: "state classes reference model size for display"
      pattern: "ModelConstants"
---

<objective>
Add all Phase 2 dependencies, configure Android and iOS platform requirements for background downloading with notifications, and create the foundational Dart types: model constants, state machine sealed class, SHA-256 chunked verifier, and storage/connectivity preflight helpers.

Purpose: Establish the dependency tree and platform permissions so the download service can operate in background on both platforms, and create the core types that the notifier and UI will consume.
Output: Compilable project with all dependencies resolved, platform manifests configured, and foundation types in lib/features/model_distribution/.
</objective>

<execution_context>
@/home/max/.claude/mowism/workflows/execute-plan.md
@/home/max/.claude/mowism/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-model-distribution/02-RESEARCH.md
@.planning/phases/02-model-distribution/02-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and configure Android/iOS platform manifests for background download</name>
  <files>
    pubspec.yaml
    android/app/src/main/AndroidManifest.xml
    ios/Runner/AppDelegate.swift
    ios/Runner.xcodeproj/project.pbxproj
    ios/Runner/Info.plist
  </files>
  <action>
    1. Add all production dependencies:
       ```
       flutter pub add background_downloader:^9.5.2
       flutter pub add connectivity_plus:^7.0.0
       flutter pub add crypto:^3.0.7
       flutter pub add path_provider:^2.1.5
       flutter pub add flutter_riverpod:^3.2.1
       flutter pub add shared_preferences:^2.5.4
       flutter pub add disk_space_plus:^0.2.6
       flutter pub add system_info_plus:^0.0.6
       ```

    2. Configure Android `android/app/src/main/AndroidManifest.xml` — add these permissions BEFORE the `<application>` tag:
       ```xml
       <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
       <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
       <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC" />
       <uses-permission android:name="android.permission.RUN_USER_INITIATED_JOBS" />
       ```
       Inside the `<application>` tag, add:
       ```xml
       <service
         android:name="androidx.work.impl.foreground.SystemForegroundService"
         android:foregroundServiceType="dataSync"
         tools:node="merge" />
       <service
         android:name="com.bbfltchimney.background_downloader.UIDTJobService"
         android:exported="false"
         android:permission="android.permission.BIND_JOB_SERVICE" />
       ```
       Also add the tools namespace to the `<manifest>` root element:
       `xmlns:tools="http://schemas.android.com/tools"`

    3. Configure iOS `ios/Runner/AppDelegate.swift` — update to set UNUserNotificationCenter delegate:
       ```swift
       import UIKit
       import Flutter
       import UserNotifications

       @main
       @objc class AppDelegate: FlutterAppDelegate {
         override func application(
           _ application: UIApplication,
           didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
         ) -> Bool {
           UNUserNotificationCenter.current().delegate = self as? UNUserNotificationCenterDelegate
           GeneratedPluginRegistrant.register(with: self)
           return super.application(application, didFinishLaunchingWithOptions: launchOptions)
         }
       }
       ```
       Note: If the existing AppDelegate uses `@UIApplicationMain` instead of `@main`, keep whichever annotation is already present. The key addition is the UNUserNotificationCenter delegate line.

    4. Enable Background Fetch in iOS. In `ios/Runner/Info.plist`, add within the top-level `<dict>`:
       ```xml
       <key>UIBackgroundModes</key>
       <array>
         <string>fetch</string>
       </array>
       ```
       If UIBackgroundModes already exists, just add the `fetch` string to the existing array.

    5. Verify the iOS Xcode project references the Info.plist correctly (it should already). If `ios/Runner.xcodeproj/project.pbxproj` needs edits for Background Modes, note that the Info.plist approach is preferred over manually editing pbxproj for capabilities.

    6. Run `flutter pub get` to verify all dependencies resolve.

    AVOID:
    - Do NOT use `flutter_downloader` (deprecated, isolate-based) — use `background_downloader`
    - Do NOT add `riverpod` without `flutter_riverpod` — we need the Flutter integration
    - Do NOT modify the Kotlin version unless `background_downloader` errors require it (it needs Kotlin 2.1.0+; check `android/settings.gradle` and update `org.jetbrains.kotlin.android` version to "2.1.0" if needed)
  </action>
  <verify>
    - `flutter pub get` completes without errors
    - `flutter analyze` has no errors in project files
    - `grep "FOREGROUND_SERVICE_DATA_SYNC" android/app/src/main/AndroidManifest.xml` returns a match
    - `grep "RUN_USER_INITIATED_JOBS" android/app/src/main/AndroidManifest.xml` returns a match
    - `grep "UNUserNotificationCenter" ios/Runner/AppDelegate.swift` returns a match
    - `grep "fetch" ios/Runner/Info.plist` returns a match within UIBackgroundModes
  </verify>
  <done>
    All 8 dependencies resolve. Android manifest has POST_NOTIFICATIONS, FOREGROUND_SERVICE, FOREGROUND_SERVICE_DATA_SYNC, RUN_USER_INITIATED_JOBS permissions plus SystemForegroundService and UIDTJobService declarations. iOS AppDelegate sets notification delegate. iOS Info.plist has Background Fetch enabled. Project compiles dependency resolution successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create model constants, state machine sealed class, SHA-256 verifier, and preflight helpers</name>
  <files>
    lib/features/model_distribution/model_constants.dart
    lib/features/model_distribution/model_distribution_state.dart
    lib/features/model_distribution/sha256_verifier.dart
    lib/features/model_distribution/storage_preflight.dart
  </files>
  <action>
    1. Create `lib/features/model_distribution/model_constants.dart` with a class containing static constants:
       - `downloadUrl`: `'https://huggingface.co/CohereLabs/tiny-aya-global-GGUF/resolve/main/tiny-aya-global-q4_k_m.gguf?download=true'`
       - `filename`: `'tiny-aya-global-q4_k_m.gguf'`
       - `fileSizeBytes`: `2299396096` (int)
       - `sha256Hash`: `'d01d995272af305b2b843efcff8a10cf9869cf53e764cb72b0e91b777484570a'`
       - `modelSubdirectory`: `'models'`
       - `requiredFreeSpaceMB`: `2560` (2.14 GB + buffer)
       - `lowMemoryThresholdMB`: `4096` (warn if device has less than 4 GB RAM)
       - `fileSizeDisplayGB`: `'~2.14 GB'` (for UI display)
       - Helper method `modelDirectory(String appSupportPath)` that returns `'$appSupportPath/models'`
       - Helper method `modelFilePath(String appSupportPath)` that returns full path to GGUF file

    2. Create `lib/features/model_distribution/model_distribution_state.dart` with a sealed class hierarchy. Follow the exact structure from RESEARCH.md Pattern 1:
       - `ModelDistributionState` (sealed base)
       - `CheckingModelState` — app just launched, checking if model exists
       - `PreflightState` — checking storage and connectivity (this is the "Preparing download..." spinner state)
       - `ResumePromptState({required double progressFraction})` — interrupted download detected, waiting for user
       - `CellularWarningState` — cellular detected, awaiting user confirmation
       - `InsufficientStorageState({required int neededBytes, required int availableBytes})` — not enough disk space
       - `DownloadingState({required double progressFraction, required int downloadedBytes, required int totalBytes, required double networkSpeedMBps, required Duration? timeRemaining})` — active download
       - `VerifyingState` — SHA-256 check in progress
       - `LowMemoryWarningState({required int availableMB})` — device RAM < 4 GB, user can proceed
       - `LoadingModelState` — model verified, loading into memory (Phase 4 wires actual load)
       - `ModelReadyState` — fully loaded, app is ready
       - `ErrorState({required String message, required int failureCount})` — failure with retry support; failureCount drives error escalation (1-2: simple retry, 3+: troubleshooting hints)
       All classes should be `const` constructors where possible. Add `@immutable` annotation on the sealed class.

    3. Create `lib/features/model_distribution/sha256_verifier.dart`:
       - A top-level function `Future<bool> verifyModelFile(String filePath)` that:
         a. Uses `compute()` (from `package:flutter/foundation.dart`) to run hash computation off the UI thread
         b. Inside the compute function: opens file with `File(path).openSync(mode: FileMode.read)`, reads 64 KB chunks in a loop, feeds to `sha256.startChunkedConversion(AccumulatorSink<Digest>())`, closes file
         c. Compares resulting digest string to `ModelConstants.sha256Hash`
         d. Returns `false` if file doesn't exist
       - Use the synchronous file API (`openSync`, `readSync`) inside compute since it runs in a separate isolate anyway — this avoids async overhead inside the isolate
       - CRITICAL: Do NOT use `File.readAsBytes()` or `File.readAsBytesSync()` — the file is 2.14 GB and will OOM on mobile
       - Import `dart:io`, `package:crypto/crypto.dart`, `package:flutter/foundation.dart`, and the model_constants file

    4. Create `lib/features/model_distribution/storage_preflight.dart` with two functions:
       a. `Future<StorageCheckResult> checkStorageSpace(String targetPath)`:
          - Uses `DiskSpacePlus().getFreeDiskSpaceForPath(targetPath)` to get free MB
          - Returns a `StorageCheckResult` sealed class: either `StorageSufficient` or `StorageInsufficient(neededMB, availableMB)`
          - Compare against `ModelConstants.requiredFreeSpaceMB`
       b. `Future<bool> isLowMemoryDevice()`:
          - Uses `SystemInfoPlus.physicalMemory` to get device RAM in MB
          - Returns `true` if RAM < `ModelConstants.lowMemoryThresholdMB`
          - Defaults to `false` (assumes sufficient) if the call fails
       c. `Future<ConnectionType> checkConnectionType()`:
          - Uses `Connectivity().checkConnectivity()` which returns `List<ConnectivityResult>`
          - If list contains `ConnectivityResult.wifi` or `ConnectivityResult.ethernet`, return `ConnectionType.wifi`
          - If list contains `ConnectivityResult.mobile`, return `ConnectionType.cellular`
          - Otherwise return `ConnectionType.none`
          - Define `enum ConnectionType { wifi, cellular, none }`
       d. Define `sealed class StorageCheckResult` with `StorageSufficient` and `StorageInsufficient(int neededMB, int availableMB)` variants

    AVOID:
    - Do NOT use `readAsBytes` for SHA-256 (OOM on 2.14 GB)
    - Do NOT use `StateNotifier` — use Riverpod 3.x `Notifier` pattern (that comes in Plan 02)
    - Do NOT put any UI code in these files — these are pure Dart logic
  </action>
  <verify>
    - `dart analyze lib/features/model_distribution/` reports no errors
    - `grep "sealed class ModelDistributionState" lib/features/model_distribution/model_distribution_state.dart` matches
    - `grep "startChunkedConversion" lib/features/model_distribution/sha256_verifier.dart` matches
    - `grep "compute" lib/features/model_distribution/sha256_verifier.dart` matches — verify it runs off UI thread
    - `grep "d01d995272af305b2b843efcff8a10cf9869cf53e764cb72b0e91b777484570a" lib/features/model_distribution/model_constants.dart` matches
    - All four files compile without errors: `dart analyze lib/features/model_distribution/model_constants.dart lib/features/model_distribution/model_distribution_state.dart lib/features/model_distribution/sha256_verifier.dart lib/features/model_distribution/storage_preflight.dart`
  </verify>
  <done>
    Four foundation files exist in lib/features/model_distribution/: model_constants.dart with hard-coded URL/hash/size, model_distribution_state.dart with a sealed class covering all 11 lifecycle states, sha256_verifier.dart with chunked compute()-isolated SHA-256 verification, and storage_preflight.dart with disk space check, RAM check, and connectivity type detection. All compile without errors and use no UI imports.
  </done>
</task>

</tasks>

<verification>
1. `flutter pub get` succeeds
2. `flutter analyze` reports no errors in lib/features/model_distribution/ and no errors from manifest changes
3. Android manifest has all 4 required permissions and 2 service declarations
4. iOS has notification delegate in AppDelegate and Background Fetch in Info.plist
5. All 4 Dart files in lib/features/model_distribution/ compile cleanly
6. SHA-256 verifier uses chunked conversion with compute() isolate, never readAsBytes
7. State machine sealed class has exactly 11 state variants
</verification>

<success_criteria>
- Project resolves all 8 new dependencies without conflicts
- Android is configured for UIDT, foreground service, and notifications
- iOS is configured for background fetch and notification delegate
- Model constants contain verified download URL and SHA-256 hash
- State machine sealed class covers: CheckingModel, Preflight, ResumePrompt, CellularWarning, InsufficientStorage, Downloading, Verifying, LowMemoryWarning, LoadingModel, ModelReady, Error
- SHA-256 verifier uses chunked streaming in a compute isolate
- Storage preflight checks disk space and RAM
- Connectivity helper detects wifi vs cellular vs none
</success_criteria>

<output>
After completion, create `.planning/phases/02-model-distribution/02-01-SUMMARY.md`
</output>
