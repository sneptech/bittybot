---
phase: 01-inference-spike
task: 1
total_tasks: 3
status: in_progress
last_updated: 2026-02-18T22:06:48.438Z
---

<current_state>
Plan 01-05 (on-device hardware verification) is in progress. We built llama.cpp native libraries from source and bundled them in the APK, but hit a runtime library loading failure on the Samsung Galaxy A25 (Android 14). The model file is already on the device.
</current_state>

<completed_work>

- Plans 01-01 through 01-04: Complete (SUMMARYs exist)
- Plan 01-05 Task 1 (Android integration tests): Partially done
  - Built llama.cpp from latest master (has Cohere2 support) for arm64-v8a using NDK 29 + system cmake 4.2.3
  - Built 5 .so files: libggml-base.so, libggml-cpu.so, libggml.so, libllama.so, libmtmd.so
  - Copied to `android/app/src/main/jniLibs/arm64-v8a/` along with libc++_shared.so
  - Verified all 6 .so files are bundled in the debug APK
  - Fixed model_loader.dart to search `/data/local/tmp/` first (Android 14 blocks /sdcard/Download/ access)
  - Pushed 2.14 GB model to device at `/data/local/tmp/tiny-aya-global-q4_k_m.gguf`
  - Ran binding load test — got `LlamaException: Failed to load model` (no llama.cpp output in logcat at all)
- Quick task 1: App logo and name set to Bittybot (committed)
</completed_work>

<remaining_work>

- **FIX: Native library loading on Android** — the critical blocker
  - libmtmd.so has NEEDED deps: libllama.so, libggml.so, libggml-cpu.so, libggml-base.so, libc++_shared.so
  - Dart FFI `DynamicLibrary.open("libmtmd.so")` may not auto-resolve transitive deps from jniLibs
  - Options: (a) rebuild with BUILD_SHARED_LIBS=OFF to produce a single static-linked libmtmd.so, or (b) explicitly load deps in order before loading libmtmd.so, or (c) add a small Java/Kotlin System.loadLibrary() call that loads all libs at app startup
  - Option (a) is cleanest — one self-contained .so, no dep chain issues
- Plan 01-05 Task 1: Re-run Android integration tests after fix
- Plan 01-05 Task 2: iOS physical device testing (checkpoint — requires user with physical iPhone)
- Plan 01-05 Task 3: LLM-as-judge evaluation and final spike report
</remaining_work>

<decisions_made>

- Built llama.cpp from latest master (not the version pinned in llama_cpp_dart 0.2.2) — needed for Cohere2 support
- Used jniLibs approach instead of AAR build — simpler, avoids llamalib hardcoded paths and OpenCL deps
- Disabled OpenCL GPU acceleration (GGML_OPENCL=OFF) — CPU-only for spike, GPU acceleration is a future optimization
- Model stored in /data/local/tmp/ for testing — avoids Android 14 scoped storage permission issues
- NDK 29.0.14033849 used for cross-compile (matches project's ndkVersion)
</decisions_made>

<blockers>
- **BLOCKER**: `DynamicLibrary.open("libmtmd.so")` fails silently on Android — no logcat output from llama.cpp at all. Most likely cause: transitive shared library dependencies not auto-resolved by Android linker when loaded via Dart FFI dlopen. Rebuild with static linking should fix this.
</blockers>

<context>
The Galaxy A25 (SM-A256E) is connected via USB, ADB working. The llama_cpp_dart package (0.2.2) defaults to `Llama.libraryPath = "libmtmd.so"` on Android (line 68 of llama.dart). The package's android/ build.gradle has CMake config but Flutter doesn't recognize it as a plugin (no flutter.plugin.platforms in pubspec). So we built the native code ourselves.

The most promising fix is rebuilding with `-DBUILD_SHARED_LIBS=OFF` so all of llama.cpp gets statically linked into a single libmtmd.so with no external deps beyond system libs. The CMake config and build dir are still at /tmp/llama-build/ — just needs a clean rebuild with the flag changed.

Build command that worked: `cd /tmp/llama-build/build-android-arm64 && cmake [flags] /tmp/llama-build/llama.cpp && cmake --build . --parallel $(nproc) --target mtmd`
</context>

<next_action>
1. Rebuild llama.cpp with `-DBUILD_SHARED_LIBS=OFF` to produce a single self-contained libmtmd.so
2. Replace the .so files in jniLibs (may only need libmtmd.so now)
3. Rebuild APK and re-run `spike_binding_load_test.dart` on the Galaxy A25
4. If that works, run all three integration test files
5. Then proceed to iOS testing (Task 2 checkpoint) and judge evaluation (Task 3)
</next_action>
