# Phase 9, Plan 01: Web Search — URL Paste, Translate, and Summarize

## Overview

Add a web search mode to the chat interface that lets users paste a URL, fetch its content, and get it translated or summarized by the on-device model. Controlled by a toggle on the input bar. Requires internet connectivity — graceful degradation when offline.

## Dependencies

- **Requires Phase 6 complete**: Web search mode is a variant of the chat input bar.
- **Parallel with Phase 7**: No dependency on chat history drawer.
- **Uses**: `ChatNotifier.sendMessage()` (feeds fetched content as user message), `connectivity_plus` (already in pubspec), `http` package (new dependency).

## Success Criteria (from ROADMAP.md)

1. A settings toggle on the text entry bar switches between normal chat mode and web search mode, with a visible mode indicator
2. In web search mode, pasting a URL and sending fetches the page content and passes it to the model for translation or summary
3. If device has no network connection, shows a clear "No internet connection" message
4. Switching off web search mode returns to normal chat behavior without app restart

## Architecture Decisions

- **Toggle on input bar** (not in settings screen): The mode switch is a quick action, not a persistent setting. A small icon button next to the text field toggles between chat mode and web mode. State is local to the input bar (not persisted in SharedPreferences — resets to chat mode on screen entry).
- **Fetch strategy**: Use `http` package (`http.get(url)`) for simplicity. Extract text from HTML via a lightweight approach: strip tags with regex for v1 (good enough for articles). Full DOM parsing (html package) is overkill for the 3.35B model's context window.
- **Content truncation**: The model's nCtx=2048 tokens (~4096 chars Latin). Fetched content is truncated to ~3000 chars before being sent to the model, leaving room for the prompt template and response.
- **Prompt construction**: Web mode uses a modified system prompt that instructs the model to translate or summarize. The user message contains the fetched content prefixed with a directive.
- **No new notifier**: Web fetch is handled in a new `WebFetchService` that returns the fetched text. The input bar calls the service, then passes the result to `ChatNotifier.sendMessage()` with a wrapped prompt. The chat flow is unchanged.
- **Connectivity check**: Use `connectivity_plus` (already a dependency) to check before fetching. If no connectivity, show a SnackBar immediately — don't attempt the fetch.

## New Dependency

**Add to `pubspec.yaml` under `dependencies:`**:
```yaml
  # Phase 9: Web Search
  http: ^1.3.0
```

## Files to Create

### 1. `lib/features/chat/data/web_fetch_service.dart`

**Purpose**: Fetches a URL, extracts text content, truncates to model-safe length.

```dart
import 'package:http/http.dart' as http;

/// Fetches web page content and extracts plain text for model processing.
///
/// Returns extracted text truncated to [maxChars] characters.
/// Throws [WebFetchException] on network errors or invalid URLs.
class WebFetchService {
  /// Maximum characters to return (leaves room for prompt template + response).
  static const int maxChars = 3000;

  /// Fetches [url] and returns extracted plain text.
  ///
  /// Steps:
  /// 1. Validates URL format (must start with http:// or https://)
  /// 2. Sends HTTP GET with 10-second timeout
  /// 3. Strips HTML tags via regex
  /// 4. Collapses whitespace
  /// 5. Truncates to [maxChars]
  Future<String> fetchAndExtract(String url) async {
    // Validate URL format
    final uri = Uri.tryParse(url);
    if (uri == null || !uri.hasScheme || (!uri.isScheme('http') && !uri.isScheme('https'))) {
      throw const WebFetchException('Invalid URL. Please enter a valid web address.');
    }

    try {
      final response = await http.get(uri).timeout(const Duration(seconds: 10));

      if (response.statusCode != 200) {
        throw WebFetchException('Failed to load page (HTTP ${response.statusCode}).');
      }

      // Strip HTML tags
      final text = response.body
          .replaceAll(RegExp(r'<script[^>]*>[\s\S]*?</script>', caseSensitive: false), '')
          .replaceAll(RegExp(r'<style[^>]*>[\s\S]*?</style>', caseSensitive: false), '')
          .replaceAll(RegExp(r'<[^>]+>'), ' ')
          .replaceAll(RegExp(r'\s+'), ' ')
          .trim();

      if (text.isEmpty) {
        throw const WebFetchException('No text content found on this page.');
      }

      // Truncate to safe length
      return text.length > maxChars ? text.substring(0, maxChars) : text;
    } on http.ClientException catch (e) {
      throw WebFetchException('Network error: ${e.message}');
    }
  }
}

/// Exception thrown by [WebFetchService] on fetch or extraction failure.
class WebFetchException implements Exception {
  final String message;
  const WebFetchException(this.message);

  @override
  String toString() => message;
}
```

### 2. `lib/features/chat/application/web_fetch_provider.dart`

**Purpose**: Riverpod provider for the web fetch service.

```dart
@riverpod
WebFetchService webFetchService(Ref ref) => WebFetchService();
```

### 3. `lib/features/chat/presentation/widgets/web_mode_indicator.dart`

**Purpose**: Small visual indicator shown when web search mode is active.

**Widget**: `WebModeIndicator extends StatelessWidget`

```
Container(
  padding: EdgeInsetsDirectional.fromSTEB(12, 4, 12, 4),
  decoration: BoxDecoration(
    color: AppColors.secondaryContainer,
    borderRadius: BorderRadius.circular(8),
  ),
  child: Row(
    mainAxisSize: MainAxisSize.min,
    children: [
      Icon(Icons.language, size: 14, color: AppColors.secondary),
      SizedBox(width: 4),
      Text(l10n.webSearchMode, style: bodySmall, color: AppColors.onSecondaryContainer),
    ],
  ),
)
```

Shown above the input field when web mode is active.

## Files to Modify

### 4. `lib/features/chat/presentation/widgets/chat_input_bar.dart`

**Changes**:

a) Add local state for web mode toggle:
```dart
bool _isWebMode = false;
```

b) Add web mode toggle button to the input row (before the TextField):
```dart
IconButton(
  icon: Icon(
    _isWebMode ? Icons.language : Icons.chat_bubble_outline,
    color: _isWebMode ? AppColors.secondary : AppColors.onSurfaceVariant,
  ),
  tooltip: _isWebMode ? l10n.switchToChat : l10n.switchToWebSearch,
  onPressed: () => setState(() => _isWebMode = !_isWebMode),
),
```

c) Add `WebModeIndicator` above the input row (conditional):
```dart
if (_isWebMode) const WebModeIndicator(),
```

d) Modify `_onSend` to handle web mode:
```dart
void _onSend(ChatState state) async {
  final text = _textController.text.trim();
  if (text.isEmpty || !state.isModelReady) return;
  _textController.clear();

  if (_isWebMode) {
    await _handleWebFetch(text);
  } else {
    ref.read(chatProvider.notifier).sendMessage(text);
  }
}
```

e) Add `_handleWebFetch` method:
```dart
Future<void> _handleWebFetch(String url) async {
  // Check connectivity first
  final connectivity = await Connectivity().checkConnectivity();
  if (connectivity.contains(ConnectivityResult.none)) {
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(l10n.noInternetConnection)),
      );
    }
    return;
  }

  // Show loading indicator (user message shows the URL)
  ref.read(chatProvider.notifier).sendMessage('[Web] $url');

  try {
    final webService = ref.read(webFetchServiceProvider);
    final content = await webService.fetchAndExtract(url);

    // Send fetched content as a follow-up message for the model to process
    final prompt = '${l10n.webSearchPrompt}\n\n$content';
    ref.read(chatProvider.notifier).sendMessage(prompt);
  } on WebFetchException catch (e) {
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(e.message)),
      );
    }
  }
}
```

f) Change hint text based on mode:
```dart
hintText: _isWebMode ? l10n.webSearchInputHint : l10n.chatInputHint,
```

g) Add imports:
```dart
import 'package:connectivity_plus/connectivity_plus.dart';
import '../../data/web_fetch_service.dart';
import '../../application/web_fetch_provider.dart';
import 'web_mode_indicator.dart';
```

### 5. `lib/features/chat/presentation/chat_screen.dart`

**No changes needed**: Web mode is entirely contained within the input bar widget. The chat screen and bubble list are unaware of web mode — they just render messages from ChatNotifier as usual.

### 6. `lib/core/l10n/app_en.arb` (and all 9 other ARB files)

**New l10n keys**:

```json
"webSearchMode": "Web mode",
"@webSearchMode": { "description": "Indicator label shown when web search mode is active" },

"switchToWebSearch": "Switch to web search",
"@switchToWebSearch": { "description": "Tooltip for the toggle button to enable web search mode" },

"switchToChat": "Switch to chat",
"@switchToChat": { "description": "Tooltip for the toggle button to return to normal chat mode" },

"webSearchInputHint": "Paste a URL to translate or summarize",
"@webSearchInputHint": { "description": "Placeholder text in the input field when web search mode is active" },

"webSearchPrompt": "Translate and summarize the following web page content:",
"@webSearchPrompt": { "description": "Prompt prefix sent to the model before fetched web page content" },

"noInternetConnection": "No internet connection",
"@noInternetConnection": { "description": "Error shown when attempting web search without network connectivity" },

"fetchingPage": "Fetching page...",
"@fetchingPage": { "description": "Loading indicator text shown while fetching a web page" }
```

### 7. `pubspec.yaml`

**Add dependency**:
```yaml
  # Phase 9: Web Search
  http: ^1.3.0
```

## Provider Wiring Summary

```
webFetchServiceProvider (auto-dispose)
    └── read by ChatInputBar._handleWebFetch

chatProvider (auto-dispose, from ChatNotifier)
    └── read by ChatInputBar for sendMessage (both chat and web mode)

Connectivity (from connectivity_plus)
    └── checked inline in _handleWebFetch before fetch attempt
```

## Widget Tree (changes only)

```
ChatInputBar (ConsumerStatefulWidget) — MODIFIED
└── SafeArea(bottom: true)
    └── Column
        ├── [if _isWebMode] WebModeIndicator  ← NEW
        ├── Row
        │   ├── IconButton(web/chat toggle)    ← NEW
        │   ├── Expanded(TextField)            ← hint text changes per mode
        │   └── IconButton(send/stop)
        └── [conditional] character counter
```

## Execution Steps (for Codex worker)

1. **Add** `http: ^1.3.0` to `pubspec.yaml` dependencies
2. **Run** `cd /home/agent/git/bittybot && flutter pub get`
3. **Create** `lib/features/chat/data/web_fetch_service.dart`
4. **Create** `lib/features/chat/application/web_fetch_provider.dart`
5. **Run** `cd /home/agent/git/bittybot && dart run build_runner build --delete-conflicting-outputs`
6. **Create** `lib/features/chat/presentation/widgets/web_mode_indicator.dart`
7. **Modify** `lib/features/chat/presentation/widgets/chat_input_bar.dart` — add toggle, web mode handling, connectivity check
8. **Add l10n keys** to all 10 ARB files (7 new keys)
9. **Run** `cd /home/agent/git/bittybot && dart run build_runner build --delete-conflicting-outputs`
10. **Run** `cd /home/agent/git/bittybot && flutter analyze`
11. **Commit**: `feat(web-search): [T-07] add web search mode with URL fetch and model processing`

## Tests

### Unit test: `test/features/chat/data/web_fetch_service_test.dart`

1. **Invalid URL**: Pass "not a url" -> throws `WebFetchException`
2. **Truncation**: Mock HTTP response with 5000-char body -> verify result is <= 3000 chars
3. **HTML stripping**: Mock response with `<p>Hello</p>` -> returns "Hello"
4. **Script/style removal**: Mock response with `<script>...</script>` -> verify script content removed
5. **Empty content**: Mock response with only HTML tags -> throws `WebFetchException`

### Widget test: `test/features/chat/presentation/widgets/chat_input_bar_web_test.dart`

1. **Toggle shows web mode indicator**: Tap toggle -> verify `WebModeIndicator` appears
2. **Toggle changes hint text**: Tap toggle -> verify hint changes to `webSearchInputHint`
3. **Toggle back to chat**: Tap toggle twice -> verify indicator gone, hint is `chatInputHint`

## Risks and Mitigations

| Risk | Mitigation |
|------|------------|
| HTML stripping is lossy | v1 acceptable — 3.35B model works better with noisy text than with complex HTML. Full DOM parsing is Phase 9.5 improvement if needed. |
| Fetched content exceeds nCtx | Truncated to 3000 chars (~1500 tokens) — well within nCtx=2048 budget after accounting for prompt template + response room. |
| Connectivity check race condition | `connectivity_plus` check is point-in-time. If connectivity drops mid-fetch, `http.get` times out (10s) and throws — caught by try/catch. |
| HTTPS-only sites with bad certs | `http.get` follows platform TLS defaults. Self-signed certs will fail — acceptable for v1 (traveler use case is mainstream websites). |
| Web mode state persists across tab switch | `_isWebMode` is local `State` in `ChatInputBar`. Since `ChatScreen` is in an `IndexedStack`, the state persists while the user is on the translation tab — this is acceptable UX. It resets on screen disposal (navigating away from main shell). |
| `[Web] url` shows as visible message | By design: user sees the URL they submitted. The follow-up message with content is the "real" input to the model. This is a deliberate UX choice — user knows what they fetched. |

## File Ownership

T-07 assignee owns:
- `lib/features/chat/data/web_fetch_service.dart` (new)
- `lib/features/chat/application/web_fetch_provider.dart` (new)
- `lib/features/chat/presentation/widgets/web_mode_indicator.dart` (new)

T-07 modifies (coordinate with Worker-2 / T-03 owner):
- `lib/features/chat/presentation/widgets/chat_input_bar.dart` — Phase 6 creates this. Must wait for Phase 6 completion.
- `pubspec.yaml` — shared file, coordinate via Agent Mail.

### Sequencing Note

Phase 9 can run **parallel with Phase 7** (different files), but both require Phase 6 to be complete first. T-07 should wait for TopazPond to signal Phase 6 done before modifying `chat_input_bar.dart`.
